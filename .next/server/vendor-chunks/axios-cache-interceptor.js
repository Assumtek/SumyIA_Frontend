"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/axios-cache-interceptor";
exports.ids = ["vendor-chunks/axios-cache-interceptor"];
exports.modules = {

/***/ "(action-browser)/./node_modules/axios-cache-interceptor/dist/index.modern.js":
/*!*******************************************************************!*\
  !*** ./node_modules/axios-cache-interceptor/dist/index.modern.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Header: () => (/* binding */ Header),\n/* harmony export */   buildKeyGenerator: () => (/* binding */ buildKeyGenerator),\n/* harmony export */   buildMemoryStorage: () => (/* binding */ buildMemoryStorage),\n/* harmony export */   buildStorage: () => (/* binding */ buildStorage),\n/* harmony export */   buildWebStorage: () => (/* binding */ buildWebStorage),\n/* harmony export */   canStale: () => (/* binding */ canStale),\n/* harmony export */   createCacheResponse: () => (/* binding */ createCacheResponse),\n/* harmony export */   createValidateStatus: () => (/* binding */ createValidateStatus),\n/* harmony export */   defaultHeaderInterpreter: () => (/* binding */ defaultHeaderInterpreter),\n/* harmony export */   defaultKeyGenerator: () => (/* binding */ defaultKeyGenerator),\n/* harmony export */   defaultRequestInterceptor: () => (/* binding */ defaultRequestInterceptor),\n/* harmony export */   defaultResponseInterceptor: () => (/* binding */ defaultResponseInterceptor),\n/* harmony export */   isExpired: () => (/* binding */ isExpired),\n/* harmony export */   isMethodIn: () => (/* binding */ isMethodIn),\n/* harmony export */   isStorage: () => (/* binding */ isStorage),\n/* harmony export */   mustRevalidate: () => (/* binding */ mustRevalidate),\n/* harmony export */   regexOrStringMatch: () => (/* binding */ regexOrStringMatch),\n/* harmony export */   setupCache: () => (/* binding */ setupCache),\n/* harmony export */   testCachePredicate: () => (/* binding */ testCachePredicate),\n/* harmony export */   updateCache: () => (/* binding */ updateCache),\n/* harmony export */   updateStaleRequest: () => (/* binding */ updateStaleRequest)\n/* harmony export */ });\n/* harmony import */ var cache_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cache-parser */ \"(action-browser)/./node_modules/cache-parser/dist/index.mjs\");\n/* harmony import */ var fast_defer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fast-defer */ \"(action-browser)/./node_modules/fast-defer/dist/index.mjs\");\n/* harmony import */ var object_code__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! object-code */ \"(action-browser)/./node_modules/object-code/dist/index.mjs\");\n/*!\n * Axios Cache Interceptor 1.8.0\n * (c) 2021-present Arthur Fiorette & Contributors\n * Released under the MIT License.\n */\n\n\n\n\nconst Header = Object.freeze({\n  /**\n   * ```txt\n   * If-Modified-Since: <day-name>, <day> <month> <year> <hour>:<minute>:<second> GMT\n   * ```\n   *\n   * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Modified-Since\n   */\n  IfModifiedSince: 'if-modified-since',\n  /**\n   * ```txt\n   * Last-Modified: <day-name>, <day> <month> <year> <hour>:<minute>:<second> GMT\n   * ```\n   *\n   * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Last-Modified\n   */\n  LastModified: 'last-modified',\n  /**\n   * ```txt\n   * If-None-Match: \"<etag_value>\"\n   * If-None-Match: \"<etag_value>\", \"<etag_value>\", â€¦\n   * If-None-Match: *\n   * ```\n   *\n   * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-None-Match\n   */\n  IfNoneMatch: 'if-none-match',\n  /**\n   * ```txt\n   * Cache-Control: max-age=604800\n   * ```\n   *\n   * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control\n   */\n  CacheControl: 'cache-control',\n  /**\n   * ```txt\n   * Pragma: no - cache;\n   * ```\n   *\n   * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Pragma\n   */\n  Pragma: 'pragma',\n  /**\n   * ```txt\n   * ETag: W / '<etag_value>';\n   * ETag: '<etag_value>';\n   * ```\n   *\n   * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag\n   */\n  ETag: 'etag',\n  /**\n   * ```txt\n   * Expires: <http-date>\n   * ```\n   *\n   * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Expires\n   */\n  Expires: 'expires',\n  /**\n   * ```txt\n   * Age: <delta-seconds>\n   * ```\n   *\n   * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Age\n   */\n  Age: 'age',\n  /**\n   * Used internally as metadata to mark the cache item as revalidatable and enabling\n   * stale cache state Contains a string of ASCII characters that can be used as ETag for\n   * `If-Match` header Provided by user using `cache.etag` value.\n   *\n   * ```txt\n   * X-Axios-Cache-Etag: \"<etag_value>\"\n   * ```\n   */\n  XAxiosCacheEtag: 'x-axios-cache-etag',\n  /**\n   * Used internally as metadata to mark the cache item as revalidatable and enabling\n   * stale cache state may contain `'use-cache-timestamp'` if `cache.modifiedSince` is\n   * `true`, otherwise will contain a date from `cache.modifiedSince`. If a date is\n   * provided, it can be used for `If-Modified-Since` header, otherwise the cache\n   * timestamp can be used for `If-Modified-Since` header.\n   *\n   * ```txt\n   * X-Axios-Cache-Last-Modified: <day-name>, <day> <month> <year> <hour>:<minute>:<second> GMT\n   * X-Axios-Cache-Last-Modified: use-cache-timestamp\n   * ```\n   */\n  XAxiosCacheLastModified: 'x-axios-cache-last-modified',\n  /**\n   * Used internally as metadata to mark the cache item able to be used if the server\n   * returns an error. The stale-if-error response directive indicates that the cache can\n   * reuse a stale response when any error occurs.\n   *\n   * ```txt\n   * XAxiosCacheStaleIfError: <seconds>\n   * ```\n   */\n  XAxiosCacheStaleIfError: 'x-axios-cache-stale-if-error'\n});\n\nconst defaultHeaderInterpreter = (headers, location) => {\n  if (!headers) return 'not enough headers';\n  const cacheControl = headers[Header.CacheControl];\n  if (cacheControl) {\n    const cc = (0,cache_parser__WEBPACK_IMPORTED_MODULE_0__.parse)(String(cacheControl));\n    if (\n    // Header told that this response should not be cached.\n    cc.noCache || cc.noStore ||\n    // Server side handling private data\n    location === 'server' && cc.private) {\n      return 'dont cache';\n    }\n    if (cc.immutable) {\n      // 1 year is sufficient, as Infinity may cause problems with certain storages.\n      // It might not be the best way, but a year is better than none. Facebook shows\n      // that a browser session stays at the most 1 month.\n      return {\n        cache: 1000 * 60 * 60 * 24 * 365\n      };\n    }\n    if (cc.maxAge !== undefined) {\n      const age = headers[Header.Age];\n      return {\n        cache: age ?\n        // If age is present, we must subtract it from maxAge\n        (cc.maxAge - Number(age)) * 1000 : cc.maxAge * 1000,\n        // Already out of date, must be requested again\n        stale:\n        // I couldn't find any documentation about who should be used, as they\n        // are not meant to overlap each other. But, as we cannot request in the\n        // background, as the stale-while-revalidate says, and we just increase\n        // its staleTtl when its present, max-stale is being preferred over\n        // stale-while-revalidate.\n        cc.maxStale !== undefined ? cc.maxStale * 1000 : cc.staleWhileRevalidate !== undefined ? cc.staleWhileRevalidate * 1000 : undefined\n      };\n    }\n  }\n  const expires = headers[Header.Expires];\n  if (expires) {\n    const milliseconds = Date.parse(String(expires)) - Date.now();\n    return milliseconds >= 0 ? {\n      cache: milliseconds\n    } : 'dont cache';\n  }\n  return 'not enough headers';\n};\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\n/** Tests an response against a {@link CachePredicateObject}. */\nasync function testCachePredicate(response, predicate) {\n  if (typeof predicate === 'function') {\n    return predicate(response);\n  }\n  const {\n    statusCheck,\n    responseMatch,\n    containsHeaders\n  } = predicate;\n  if (statusCheck && !(await statusCheck(response.status)) || responseMatch && !(await responseMatch(response))) {\n    return false;\n  }\n  if (containsHeaders) {\n    for (const [header, _predicate] of Object.entries(containsHeaders)) {\n      var _response$headers$hea;\n      if (!(await _predicate( // Avoid bugs in case the header is not in lower case\n      (_response$headers$hea = response.headers[header.toLowerCase()]) != null ? _response$headers$hea : response.headers[header]))) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n/**\n * Determines whether a given URL matches a specified pattern, which can be either a string or a regular expression.\n *\n * @param matchPattern - The pattern to match against\n *   - If it's a regular expression, it will be reset to ensure consistent behavior for stateful regular expressions.\n *   - If it's a string, the function checks if the URL contains the string.\n * @param configUrl - The URL to test against the provided pattern; normally `config.url`.\n * @returns `true` if the `configUrl` matches the `matchPattern`\n */\nfunction regexOrStringMatch(matchPattern, configUrl) {\n  if (matchPattern instanceof RegExp) {\n    matchPattern.lastIndex = 0; // Reset the regex to ensure consistent matching\n    return matchPattern.test(configUrl);\n  }\n  return configUrl.includes(matchPattern);\n}\n\n/**\n * Creates a new validateStatus function that will use the one already used and also\n * accept status code 304.\n */\nfunction createValidateStatus(oldValidate) {\n  return oldValidate ? status => oldValidate(status) || status === 304 : status => status >= 200 && status < 300 || status === 304;\n}\n/** Checks if the given method is in the methods array */\nfunction isMethodIn(requestMethod = 'get', methodList = []) {\n  requestMethod = requestMethod.toLowerCase();\n  return methodList.some(method => method === requestMethod);\n}\n/**\n * This function updates the cache when the request is stale. So, the next request to the\n * server will be made with proper header / settings.\n */\nfunction updateStaleRequest(cache, config) {\n  config.headers || (config.headers = {});\n  const {\n    etag,\n    modifiedSince\n  } = config.cache;\n  if (etag) {\n    var _cache$data;\n    const etagValue = etag === true ? (_cache$data = cache.data) == null ? void 0 : _cache$data.headers[Header.ETag] : etag;\n    if (etagValue) {\n      config.headers[Header.IfNoneMatch] = etagValue;\n    }\n  }\n  if (modifiedSince) {\n    config.headers[Header.IfModifiedSince] = modifiedSince === true ?\n    // If last-modified is not present, use the createdAt timestamp\n    cache.data.headers[Header.LastModified] || new Date(cache.createdAt).toUTCString() : modifiedSince.toUTCString();\n  }\n}\n/**\n * Creates the new date to the cache by the provided response. Also handles possible 304\n * Not Modified by updating response properties.\n */\nfunction createCacheResponse(response, previousCache) {\n  if (response.status === 304 && previousCache) {\n    // Set the cache information into the response object\n    response.cached = true;\n    response.data = previousCache.data;\n    response.status = previousCache.status;\n    response.statusText = previousCache.statusText;\n    // Update possible new headers\n    response.headers = _extends({}, previousCache.headers, response.headers);\n    // return the old cache\n    return previousCache;\n  }\n  // New Response\n  return {\n    data: response.data,\n    status: response.status,\n    statusText: response.statusText,\n    headers: response.headers\n  };\n}\n\nfunction defaultRequestInterceptor(axios) {\n  const onFulfilled = async config => {\n    config.id = axios.generateKey(config);\n    if (config.cache === false) {\n      return config;\n    }\n    // merge defaults with per request configuration\n    config.cache = _extends({}, axios.defaults.cache, config.cache);\n    // ignoreUrls (blacklist)\n    if (typeof config.cache.cachePredicate === 'object' && config.cache.cachePredicate.ignoreUrls && config.url) {\n      for (const url of config.cache.cachePredicate.ignoreUrls) {\n        if (regexOrStringMatch(url, config.url)) {\n          return config;\n        }\n      }\n    }\n    // allowUrls\n    if (typeof config.cache.cachePredicate === 'object' && config.cache.cachePredicate.allowUrls && config.url) {\n      let matched = false;\n      for (const url of config.cache.cachePredicate.allowUrls) {\n        if (regexOrStringMatch(url, config.url)) {\n          matched = true;\n          break;\n        }\n      }\n      if (!matched) {\n        return config;\n      }\n    }\n    // Applies sufficient headers to prevent other cache systems to work along with this one\n    //\n    // Its currently used before isMethodIn because if the isMethodIn returns false, the request\n    // shouldn't be cached an therefore neither in the browser.\n    if (config.cache.cacheTakeover) {\n      var _config$headers, _Header$CacheControl, _config$headers$_Head, _config$headers2, _Header$Pragma, _config$headers2$_Hea, _config$headers3, _Header$Expires, _config$headers3$_Hea;\n      (_config$headers$_Head = (_config$headers = config.headers)[_Header$CacheControl = Header.CacheControl]) != null ? _config$headers$_Head : _config$headers[_Header$CacheControl] = 'no-cache';\n      (_config$headers2$_Hea = (_config$headers2 = config.headers)[_Header$Pragma = Header.Pragma]) != null ? _config$headers2$_Hea : _config$headers2[_Header$Pragma] = 'no-cache';\n      (_config$headers3$_Hea = (_config$headers3 = config.headers)[_Header$Expires = Header.Expires]) != null ? _config$headers3$_Hea : _config$headers3[_Header$Expires] = '0';\n    }\n    if (!isMethodIn(config.method, config.cache.methods)) {\n      return config;\n    }\n    // Assumes that the storage handled staled responses\n    let cache = await axios.storage.get(config.id, config);\n    const overrideCache = config.cache.override;\n    // Not cached, continue the request, and mark it as fetching\n    // biome-ignore lint/suspicious/noConfusingLabels: required to break condition in simultaneous accesses\n    ignoreAndRequest: if (cache.state === 'empty' || cache.state === 'stale' || cache.state === 'must-revalidate' || overrideCache) {\n      // This checks for simultaneous access to a new key. The js event loop jumps on the\n      // first await statement, so the second (asynchronous call) request may have already\n      // started executing.\n      if (axios.waiting.has(config.id) && !overrideCache) {\n        cache = await axios.storage.get(config.id, config);\n        // @ts-expect-error This check is required when a request has it own cache deleted manually, lets\n        // say by a `axios.storage.delete(key)` and has a concurrent loading request.\n        // Because in this case, the cache will be empty and may still has a pending key\n        // on waiting map.\n        if (cache.state !== 'empty' && cache.state !== 'must-revalidate') {\n          break ignoreAndRequest;\n        }\n      }\n      // Create a deferred to resolve other requests for the same key when it's completed\n      const def = (0,fast_defer__WEBPACK_IMPORTED_MODULE_1__.deferred)();\n      axios.waiting.set(config.id, def);\n      // Adds a default reject handler to catch when the request gets aborted without\n      // others waiting for it.\n      def.catch(() => undefined);\n      await axios.storage.set(config.id, {\n        state: 'loading',\n        previous: overrideCache ?\n        // Simply determine if the request is stale or not\n        // based if it had previous data or not\n        cache.data ? 'stale' : 'empty' :\n        // Typescript doesn't know that cache.state here can only be 'empty' or 'stale'\n        cache.state,\n        data: cache.data,\n        // If the cache is empty and asked to override it, use the current timestamp\n        createdAt: overrideCache && !cache.createdAt ? Date.now() : cache.createdAt\n      }, config);\n      if (cache.state === 'stale' || cache.state === 'must-revalidate') {\n        updateStaleRequest(cache, config);\n      }\n      config.validateStatus = createValidateStatus(config.validateStatus);\n      // Hydrates any UI temporarily, if cache is available\n      if (cache.state === 'stale' || cache.data && cache.state !== 'must-revalidate') {\n        await (config.cache.hydrate == null ? void 0 : config.cache.hydrate(cache));\n      }\n      return config;\n    }\n    let cachedResponse;\n    if (cache.state === 'loading') {\n      const deferred = axios.waiting.get(config.id);\n      // The deferred may not exists when the process is using a persistent\n      // storage and cancelled  in the middle of a request, this would result in\n      // a pending loading state in the storage but no current promises to resolve\n      if (!deferred) {\n        // Hydrates any UI temporarily, if cache is available\n        if (cache.data) {\n          await (config.cache.hydrate == null ? void 0 : config.cache.hydrate(cache));\n        }\n        return config;\n      }\n      try {\n        // Deferred can't reuse the value because the user's storage might clone\n        // or mutate the value, so we need to ask it again.\n        // For example with memoryStorage + cloneData\n        await deferred;\n        const state = await axios.storage.get(config.id, config);\n        // This is a cache mismatch and should never happen, but in case it does,\n        // we need to redo the request all over again.\n        /* c8 ignore start */\n        if (!state.data) {\n          if (false) {}\n          return onFulfilled(config);\n        }\n        /* c8 ignore end */\n        cachedResponse = state.data;\n      } catch (err) {\n        // Hydrates any UI temporarily, if cache is available\n        /* c8 ignore start */\n        if (cache.data) {\n          await (config.cache.hydrate == null ? void 0 : config.cache.hydrate(cache));\n        }\n        /* c8 ignore end */\n        // The deferred is rejected when the request that we are waiting rejects its cache.\n        // In this case, we need to redo the request all over again.\n        return onFulfilled(config);\n      }\n    } else {\n      cachedResponse = cache.data;\n    }\n    // The cached data is already transformed after receiving the response from the server.\n    // Reapplying the transformation on the transformed data will have an unintended effect.\n    // Since the cached data is already in the desired format, there is no need to apply the transformation function again.\n    config.transformResponse = undefined;\n    // Even though the response interceptor receives this one from here,\n    // it has been configured to ignore cached responses = true\n    config.adapter = function cachedAdapter() {\n      return Promise.resolve({\n        config,\n        data: cachedResponse.data,\n        headers: cachedResponse.headers,\n        status: cachedResponse.status,\n        statusText: cachedResponse.statusText,\n        cached: true,\n        stale: cache.previous === 'stale',\n        id: config.id\n      });\n    };\n    return config;\n  };\n  return {\n    onFulfilled\n  };\n}\n\n/** Function to update all caches, from CacheProperties.update, with the new data. */\nasync function updateCache(storage, data, cacheUpdater) {\n  // Global cache update function.\n  if (typeof cacheUpdater === 'function') {\n    return cacheUpdater(data);\n  }\n  for (const [cacheKey, updater] of Object.entries(cacheUpdater)) {\n    if (updater === 'delete') {\n      await storage.remove(cacheKey, data.config);\n      continue;\n    }\n    const value = await storage.get(cacheKey, data.config);\n    if (value.state === 'loading') {\n      continue;\n    }\n    const newValue = await updater(value, data);\n    if (newValue === 'delete') {\n      await storage.remove(cacheKey, data.config);\n      continue;\n    }\n    if (newValue !== 'ignore') {\n      await storage.set(cacheKey, newValue, data.config);\n    }\n  }\n}\n\nfunction defaultResponseInterceptor(axios) {\n  /**\n   * Rejects cache for an response response.\n   *\n   * Also update the waiting list for this key by rejecting it.\n   */\n  const rejectResponse = async (responseId, config, clearCache) => {\n    // Updates the cache to empty to prevent infinite loading state\n    if (clearCache) {\n      await axios.storage.remove(responseId, config);\n    }\n    // Rejects the deferred, if present\n    const deferred = axios.waiting.get(responseId);\n    if (deferred) {\n      deferred.reject();\n      axios.waiting.delete(responseId);\n    }\n  };\n  const onFulfilled = async response => {\n    var _response$cached;\n    // When response.config is not present, the response is indeed a error.\n    if (!(response != null && response.config)) {\n      // Re-throws the error\n      throw response;\n    }\n    response.id = response.config.id;\n    (_response$cached = response.cached) != null ? _response$cached : response.cached = false;\n    const config = response.config;\n    // Request interceptor merges defaults with per request configuration\n    const cacheConfig = config.cache;\n    // Response is already cached\n    if (response.cached) {\n      return response;\n    }\n    // Skip cache: either false or weird behavior\n    // config.cache should always exists, at least from global config merge.\n    if (!cacheConfig) {\n      response.cached = false;\n      return response;\n    }\n    // Update other entries before updating himself\n    if (cacheConfig.update) {\n      await updateCache(axios.storage, response, cacheConfig.update);\n    }\n    if (!isMethodIn(config.method, cacheConfig.methods)) {\n      return response;\n    }\n    const cache = await axios.storage.get(response.id, config);\n    if (\n    // If the request interceptor had a problem or it wasn't cached\n    cache.state !== 'loading') {\n      return response;\n    }\n    // Config told that this response should be cached.\n    if (\n    // For 'loading' values (previous: stale), this check already ran in the past.\n    !cache.data && !(await testCachePredicate(response, cacheConfig.cachePredicate))) {\n      await rejectResponse(response.id, config, true);\n      return response;\n    }\n    // Avoid remnant headers from remote server to break implementation\n    for (const header of Object.keys(response.headers)) {\n      if (header.startsWith('x-axios-cache')) {\n        delete response.headers[header];\n      }\n    }\n    if (cacheConfig.etag && cacheConfig.etag !== true) {\n      response.headers[Header.XAxiosCacheEtag] = cacheConfig.etag;\n    }\n    if (cacheConfig.modifiedSince) {\n      response.headers[Header.XAxiosCacheLastModified] = cacheConfig.modifiedSince === true ? 'use-cache-timestamp' : cacheConfig.modifiedSince.toUTCString();\n    }\n    let ttl = cacheConfig.ttl || -1; // always set from global config\n    let staleTtl;\n    if (cacheConfig.interpretHeader) {\n      const expirationTime = axios.headerInterpreter(response.headers, axios.location);\n      // Cache should not be used\n      if (expirationTime === 'dont cache') {\n        await rejectResponse(response.id, config, true);\n        return response;\n      }\n      if (expirationTime !== 'not enough headers') {\n        if (typeof expirationTime === 'number') {\n          ttl = expirationTime;\n        } else {\n          ttl = expirationTime.cache;\n          staleTtl = expirationTime.stale;\n        }\n      }\n    }\n    const data = createCacheResponse(response, cache.data);\n    if (typeof ttl === 'function') {\n      ttl = await ttl(response);\n    }\n    if (cacheConfig.staleIfError) {\n      response.headers[Header.XAxiosCacheStaleIfError] = String(ttl);\n    }\n    const newCache = {\n      state: 'cached',\n      ttl,\n      staleTtl,\n      createdAt: Date.now(),\n      data\n    };\n    // Define this key as cache on the storage\n    await axios.storage.set(response.id, newCache, config);\n    // Resolve all other requests waiting for this response\n    const waiting = axios.waiting.get(response.id);\n    if (waiting) {\n      waiting.resolve();\n      axios.waiting.delete(response.id);\n    }\n    // Return the response with cached as false, because it was not cached at all\n    return response;\n  };\n  const onRejected = async error => {\n    // When response.config is not present, the response is indeed a error.\n    if (!error.isAxiosError || !error.config) {\n      // We should probably re-request the response to avoid an infinite loading state here\n      // but, since this is an unknown error, we cannot figure out what request ID to use.\n      // And the only solution is to let the storage actively reject the current loading state.\n      throw error;\n    }\n    const config = error.config;\n    const id = config.id;\n    const cacheConfig = config.cache;\n    const response = error.response;\n    // config.cache should always exist, at least from global config merge.\n    if (!cacheConfig || !id) {\n      throw error;\n    }\n    if (!isMethodIn(config.method, cacheConfig.methods)) {\n      // Rejects all other requests waiting for this response\n      await rejectResponse(id, config, true);\n      throw error;\n    }\n    const cache = await axios.storage.get(id, config);\n    if (\n    // This will only not be loading if the interceptor broke\n    cache.state !== 'loading' || cache.previous !== 'stale') {\n      // Rejects all other requests waiting for this response\n      await rejectResponse(id, config,\n      // Do not clear cache if this request is cached, but the request was cancelled before returning the cached response\n      error.code !== 'ERR_CANCELED' || error.code === 'ERR_CANCELED' && cache.state !== 'cached');\n      throw error;\n    }\n    if (cacheConfig.staleIfError) {\n      const cacheControl = String(response == null ? void 0 : response.headers[Header.CacheControl]);\n      const staleHeader = cacheControl && (0,cache_parser__WEBPACK_IMPORTED_MODULE_0__.parse)(cacheControl).staleIfError;\n      const staleIfError = typeof cacheConfig.staleIfError === 'function' ? await cacheConfig.staleIfError(response, cache, error) : cacheConfig.staleIfError === true && staleHeader ? staleHeader * 1000 //staleIfError is in seconds\n      : cacheConfig.staleIfError;\n      if (staleIfError === true ||\n      // staleIfError is the number of seconds that stale is allowed to be used\n      typeof staleIfError === 'number' && cache.createdAt + staleIfError > Date.now()) {\n        // re-mark the cache as stale\n        await axios.storage.set(id, {\n          state: 'stale',\n          createdAt: Date.now(),\n          data: cache.data\n        }, config);\n        // Resolve all other requests waiting for this response\n        const waiting = axios.waiting.get(id);\n        if (waiting) {\n          waiting.resolve();\n          axios.waiting.delete(id);\n        }\n        return {\n          cached: true,\n          stale: true,\n          config,\n          id,\n          data: cache.data.data,\n          headers: cache.data.headers,\n          status: cache.data.status,\n          statusText: cache.data.statusText\n        };\n      }\n    }\n    // Rejects all other requests waiting for this response\n    await rejectResponse(id, config, true);\n    throw error;\n  };\n  return {\n    onFulfilled,\n    onRejected\n  };\n}\n\n/** Returns true if the provided object was created from {@link buildStorage} function. */\nconst isStorage = obj => !!obj && !!obj['is-storage'];\nfunction hasUniqueIdentifierHeader(value) {\n  const headers = value.data.headers;\n  return Header.ETag in headers || Header.LastModified in headers || Header.XAxiosCacheEtag in headers || Header.XAxiosCacheLastModified in headers;\n}\n/** Returns true if value must be revalidated */\nfunction mustRevalidate(value) {\n  // Must revalidate is a special case and should not serve stale values\n  // We could use cache-control's parse function, but this is way faster and simpler\n  return String(value.data.headers[Header.CacheControl]).includes('must-revalidate');\n}\n/** Returns true if this has sufficient properties to stale instead of expire. */\nfunction canStale(value) {\n  if (hasUniqueIdentifierHeader(value)) {\n    return true;\n  }\n  return value.state === 'cached' && value.staleTtl !== undefined &&\n  // Only allow stale values after the ttl is already in the past and the staleTtl is in the future.\n  // In cases that just createdAt + ttl > Date.now(), isn't enough because the staleTtl could be <= 0.\n  // This logic only returns true when Date.now() is between the (createdAt + ttl) and (createdAt + ttl + staleTtl).\n  // Following the example below:\n  // |--createdAt--:--ttl--:---staleTtl--->\n  // [        past        ][now is in here]\n  Math.abs(Date.now() - (value.createdAt + value.ttl)) <= value.staleTtl;\n}\n/**\n * Checks if the provided cache is expired. You should also check if the cache\n * {@link canStale} and {@link mayUseStale}\n */\nfunction isExpired(value) {\n  return value.ttl !== undefined && value.createdAt + value.ttl <= Date.now();\n}\n/**\n * All integrated storages are wrappers around the `buildStorage` function. External\n * libraries use it and if you want to build your own, `buildStorage` is the way to go!\n *\n * The exported `buildStorage` function abstracts the storage interface and requires a\n * super simple object to build the storage.\n *\n * **Note**: You can only create an custom storage with this function.\n *\n * @example\n *\n * ```js\n * const myStorage = buildStorage({\n *   find: () => {...},\n *   set: () => {...},\n *   remove: () => {...},\n *   clear: () => {...}\n * });\n *\n * const axios = setupCache(axios, { storage: myStorage });\n * ```\n *\n * @see https://axios-cache-interceptor.js.org/guide/storages#buildstorage\n */\nfunction buildStorage({\n  set,\n  find,\n  remove,\n  clear\n}) {\n  return {\n    //@ts-expect-error - we don't want to expose this\n    'is-storage': 1,\n    set,\n    remove,\n    clear,\n    get: async (key, config) => {\n      let value = await find(key, config);\n      if (!value) {\n        return {\n          state: 'empty'\n        };\n      }\n      if (value.state === 'empty' || value.state === 'loading' || value.state === 'must-revalidate') {\n        return value;\n      }\n      // Handle cached values\n      if (value.state === 'cached') {\n        if (!isExpired(value)) {\n          return value;\n        }\n        // Tries to stale expired value\n        if (!canStale(value)) {\n          await remove(key, config);\n          return {\n            state: 'empty'\n          };\n        }\n        value = {\n          state: 'stale',\n          createdAt: value.createdAt,\n          data: value.data,\n          ttl: value.staleTtl !== undefined ? value.staleTtl + value.ttl : undefined\n        };\n        await set(key, value, config);\n        // Must revalidate is a special case and should not serve stale values\n        if (mustRevalidate(value)) {\n          return _extends({}, value, {\n            state: 'must-revalidate'\n          });\n        }\n      }\n      // A second check in case the new stale value was created already expired.\n      if (!isExpired(value)) {\n        return value;\n      }\n      if (hasUniqueIdentifierHeader(value)) {\n        return value;\n      }\n      await remove(key, config);\n      return {\n        state: 'empty'\n      };\n    }\n  };\n}\n\n/* c8 ignore start */\n/**\n * Clones an object using the structured clone algorithm if available, otherwise\n * it uses JSON.parse(JSON.stringify(value)).\n */\nconst clone =\n// https://caniuse.com/mdn-api_structuredclone (10/18/2023 92.51%)\ntypeof structuredClone === 'function' ? structuredClone : value => JSON.parse(JSON.stringify(value));\n/* c8 ignore stop */\n/**\n * Creates a simple in-memory storage. This means that if you need to persist data between\n * page or server reloads, this will not help.\n *\n * This is the storage used by default.\n *\n * If you need to modify it's data, you can do by the `data` property.\n *\n * @example\n *\n * ```js\n * const memoryStorage = buildMemoryStorage();\n *\n * setupCache(axios, { storage: memoryStorage });\n *\n * // Simple example to force delete the request cache\n *\n * const { id } = axios.get('url');\n *\n * delete memoryStorage.data[id];\n * ```\n *\n * @param {boolean | 'double'} cloneData Use `true` if the data returned by `find()`\n *   should be cloned to avoid mutating the original data outside the `set()` method. Use\n *   `'double'` to also clone before saving value in storage using `set()`. Disabled is\n *   default\n * @param {number | false} cleanupInterval The interval in milliseconds to run a\n *   setInterval job of cleaning old entries. If false, the job will not be created.\n *   Disabled is default\n * @param {number | false} maxEntries The maximum number of entries to keep in the\n *   storage. Its hard to determine the size of the entries, so a smart FIFO order is used\n *   to determine eviction. If false, no check will be done and you may grow up memory\n *   usage. Disabled is default\n */\nfunction buildMemoryStorage(cloneData = false, cleanupInterval = false, maxEntries = false) {\n  const storage = buildStorage({\n    set: (key, value) => {\n      if (maxEntries) {\n        let keys = Object.keys(storage.data);\n        // Tries to cleanup first\n        if (keys.length >= maxEntries) {\n          storage.cleanup();\n          // Recalculates the keys\n          keys = Object.keys(storage.data);\n          // Keeps deleting until there's space\n          while (keys.length >= maxEntries) {\n            // There's always at least one key here, otherwise it would not be\n            // in the loop.\n            delete storage.data[keys.shift()];\n          }\n        }\n      }\n      // Clone the value before storing to prevent future mutations\n      // from affecting cached data.\n      storage.data[key] = cloneData === 'double' ? clone(value) : value;\n    },\n    remove: key => {\n      delete storage.data[key];\n    },\n    find: key => {\n      const value = storage.data[key];\n      return cloneData && value !== undefined ? clone(value) : value;\n    },\n    clear: () => {\n      storage.data = Object.create(null);\n    }\n  });\n  storage.data = Object.create(null);\n  // When this program gets running for more than the specified interval, there's a good\n  // chance of it being a long-running process or at least have a lot of entries. Therefore,\n  // \"faster\" loop is more important than code readability.\n  storage.cleanup = () => {\n    const keys = Object.keys(storage.data);\n    let i = -1;\n    let value;\n    let key;\n    // Looping forward, as older entries are more likely to be expired\n    // than newer ones.\n    while (++i < keys.length) {\n      key = keys[i];\n      value = storage.data[key];\n      if (value.state === 'empty') {\n        storage.remove(key);\n        continue;\n      }\n      // If the value is expired and can't be stale, remove it\n      if (value.state === 'cached' && isExpired(value) && !canStale(value)) {\n        // this storage returns void.\n        storage.remove(key);\n      }\n    }\n  };\n  if (cleanupInterval) {\n    storage.cleaner = setInterval(storage.cleanup, cleanupInterval);\n  }\n  return storage;\n}\n\n// Remove first and last '/' char, if present\nconst SLASHES_REGEX = /^\\/|\\/$/g;\n/**\n * Builds an generator that receives a {@link CacheRequestConfig} and returns a value\n * hashed by {@link hash}.\n *\n * The value is hashed into a signed integer when the returned value from the provided\n * generator is not a `string` or a `number`.\n *\n * You can return any type of data structure.\n *\n * @example\n *\n * ```js\n * // This generator will return a hash code.\n * // The code will only be the same if url, method and data are the same.\n * const generator = buildKeyGenerator(({ url, method, data }) => ({\n *   url,\n *   method,\n *   data\n * }));\n * ```\n */\nfunction buildKeyGenerator(generator) {\n  return request => {\n    if (request.id) {\n      return request.id;\n    }\n    const key = generator(request);\n    if (typeof key === 'string' || typeof key === 'number') {\n      return `${key}`;\n    }\n    return `${(0,object_code__WEBPACK_IMPORTED_MODULE_2__.hash)(key)}`;\n  };\n}\nconst defaultKeyGenerator = buildKeyGenerator(({\n  baseURL,\n  url,\n  method,\n  params,\n  data\n}) => {\n  // Remove trailing slashes to avoid generating different keys for the \"same\" final url.\n  if (baseURL !== undefined) {\n    baseURL = baseURL.replace(SLASHES_REGEX, '');\n  } else {\n    // just to have a consistent hash\n    baseURL = '';\n  }\n  if (url !== undefined) {\n    url = url.replace(SLASHES_REGEX, '');\n  } else {\n    // just to have a consistent hash\n    url = '';\n  }\n  if (method !== undefined) {\n    method = method.toLowerCase();\n  } else {\n    // just to have a consistent hash\n    method = 'get';\n  }\n  return {\n    url: baseURL + (baseURL && url ? '/' : '') + url,\n    params: params,\n    method: method,\n    data: data\n  };\n});\n\n/**\n * Apply the caching interceptors for a already created axios instance.\n *\n * ```ts\n * const axios = setupCache(axios, OPTIONS);\n * ```\n *\n * The `setupCache` function receives global options and all [request\n * specifics](https://axios-cache-interceptor.js.org/config/request-specifics) ones too.\n * This way, you can customize the defaults for all requests.\n *\n * @param axios The already created axios instance\n * @param config The config for the caching interceptors\n * @returns The same instance with extended typescript types.\n * @see https://axios-cache-interceptor.js.org/config\n */\nfunction setupCache(axios, options = {}) {\n  var _options$ttl, _options$etag, _options$modifiedSinc, _options$interpretHea, _options$cacheTakeove, _options$staleIfError, _options$override, _options$hydrate;\n  const axiosCache = axios;\n  if (axiosCache.defaults.cache) {\n    throw new Error('setupCache() should be called only once');\n  }\n  axiosCache.location = typeof window === 'undefined' ? 'server' : 'client';\n  axiosCache.storage = options.storage || buildMemoryStorage();\n  if (!isStorage(axiosCache.storage)) {\n    throw new Error('Use buildStorage() function');\n  }\n  axiosCache.waiting = options.waiting || new Map();\n  axiosCache.generateKey = options.generateKey || defaultKeyGenerator;\n  axiosCache.headerInterpreter = options.headerInterpreter || defaultHeaderInterpreter;\n  axiosCache.requestInterceptor = options.requestInterceptor || defaultRequestInterceptor(axiosCache);\n  axiosCache.responseInterceptor = options.responseInterceptor || defaultResponseInterceptor(axiosCache);\n  axiosCache.debug = options.debug || function noop() {};\n  // CacheRequestConfig values\n  axiosCache.defaults.cache = {\n    update: options.update || {},\n    ttl: (_options$ttl = options.ttl) != null ? _options$ttl : 1000 * 60 * 5,\n    // Although RFC 7231 also marks POST as cacheable, most users don't know that\n    // and may have problems about why their \"create X\" route not working.\n    methods: options.methods || ['get', 'head'],\n    cachePredicate: options.cachePredicate || {\n      // All cacheable status codes defined in RFC 7231\n      statusCheck: status => [200, 203, 300, 301, 302, 404, 405, 410, 414, 501].includes(status)\n    },\n    etag: (_options$etag = options.etag) != null ? _options$etag : true,\n    // This option is going to be ignored by servers when ETag is enabled\n    // Checks strict equality to false to avoid undefined-ish values\n    modifiedSince: (_options$modifiedSinc = options.modifiedSince) != null ? _options$modifiedSinc : options.etag === false,\n    interpretHeader: (_options$interpretHea = options.interpretHeader) != null ? _options$interpretHea : true,\n    cacheTakeover: (_options$cacheTakeove = options.cacheTakeover) != null ? _options$cacheTakeove : true,\n    staleIfError: (_options$staleIfError = options.staleIfError) != null ? _options$staleIfError : true,\n    override: (_options$override = options.override) != null ? _options$override : false,\n    hydrate: (_options$hydrate = options.hydrate) != null ? _options$hydrate : undefined\n  };\n  // Apply interceptors\n  axiosCache.interceptors.request.use(axiosCache.requestInterceptor.onFulfilled, axiosCache.requestInterceptor.onRejected);\n  axiosCache.interceptors.response.use(axiosCache.responseInterceptor.onFulfilled, axiosCache.responseInterceptor.onRejected);\n  return axiosCache;\n}\n\n/**\n * Creates a simple storage. You can persist his data by using `sessionStorage` or\n * `localStorage` with it.\n *\n * **ImplNote**: Without polyfill, this storage only works on browser environments.\n *\n * @example\n *\n * ```js\n * const fromLocalStorage = buildWebStorage(localStorage);\n * const fromSessionStorage = buildWebStorage(sessionStorage);\n *\n * const myStorage = new Storage();\n * const fromMyStorage = buildWebStorage(myStorage);\n * ```\n *\n * @param storage The type of web storage to use. localStorage or sessionStorage.\n * @param prefix The prefix to index the storage. Useful to prevent collision between\n *   multiple places using the same storage.\n */\nfunction buildWebStorage(storage, prefix = 'axios-cache-') {\n  return buildStorage({\n    clear: () => {\n      for (const key in storage) {\n        if (key.startsWith(prefix)) {\n          storage.removeItem(key);\n        }\n      }\n    },\n    find: key => {\n      const json = storage.getItem(prefix + key);\n      return json ? JSON.parse(json) : undefined;\n    },\n    remove: key => {\n      storage.removeItem(prefix + key);\n    },\n    set: (key, value) => {\n      const save = () => storage.setItem(prefix + key, JSON.stringify(value));\n      try {\n        return save();\n      } catch (error) {\n        const allValues = Object.entries(storage).filter(item => item[0].startsWith(prefix)).map(item => [item[0], JSON.parse(item[1])]);\n        // Remove all expired values\n        for (const _value of allValues) {\n          if (_value[1].state === 'cached' && isExpired(_value[1]) && !canStale(_value[1])) {\n            storage.removeItem(_value[0]);\n          }\n        }\n        // Try save again after removing expired values\n        try {\n          return save();\n        } catch (_unused) {\n          // Storage still full, try removing the oldest value until it can be saved\n          // Descending sort by createdAt\n          const sortedItems = allValues.sort((a, b) => (a[1].createdAt || 0) - (b[1].createdAt || 0));\n          for (const item of sortedItems) {\n            storage.removeItem(item[0]);\n            try {\n              return save();\n            } catch (_unused2) {\n              // This key didn't free all the required space\n            }\n          }\n        }\n        // Clear the cache for the specified key\n        storage.removeItem(prefix + key);\n      }\n    }\n  });\n}\n\n\n//# sourceMappingURL=index.modern.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy1jYWNoZS1pbnRlcmNlcHRvci9kaXN0L2luZGV4Lm1vZGVybi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3FDO0FBQ0M7QUFDSDs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1EQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQywyQkFBMkI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9EQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEtBQUssRUFBRSxFQUFDO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsbURBQUs7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBEQUEwRCxvQkFBb0I7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnQkFBZ0IsS0FBSztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLElBQUk7QUFDdEIsaUJBQWlCLElBQUk7QUFDckIsb0JBQW9CLElBQUk7QUFDeEIsbUJBQW1CO0FBQ25CLElBQUk7QUFDSjtBQUNBLHFDQUFxQyxvQkFBb0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHdCQUF3QjtBQUMvQztBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQjtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsMEJBQTBCO0FBQ2xFLGNBQWMsV0FBVztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLG1CQUFtQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLElBQUk7QUFDcEI7QUFDQSxjQUFjLGlEQUFJLE1BQU07QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUUwWDtBQUMxWCIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2F4aW9zLWNhY2hlLWludGVyY2VwdG9yL2Rpc3QvaW5kZXgubW9kZXJuLmpzPzgxN2YiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBBeGlvcyBDYWNoZSBJbnRlcmNlcHRvciAxLjguMFxuICogKGMpIDIwMjEtcHJlc2VudCBBcnRodXIgRmlvcmV0dGUgJiBDb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgcGFyc2UgfSBmcm9tICdjYWNoZS1wYXJzZXInO1xuaW1wb3J0IHsgZGVmZXJyZWQgfSBmcm9tICdmYXN0LWRlZmVyJztcbmltcG9ydCB7IGhhc2ggfSBmcm9tICdvYmplY3QtY29kZSc7XG5cbmNvbnN0IEhlYWRlciA9IE9iamVjdC5mcmVlemUoe1xuICAvKipcbiAgICogYGBgdHh0XG4gICAqIElmLU1vZGlmaWVkLVNpbmNlOiA8ZGF5LW5hbWU+LCA8ZGF5PiA8bW9udGg+IDx5ZWFyPiA8aG91cj46PG1pbnV0ZT46PHNlY29uZD4gR01UXG4gICAqIGBgYFxuICAgKlxuICAgKiBAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvSWYtTW9kaWZpZWQtU2luY2VcbiAgICovXG4gIElmTW9kaWZpZWRTaW5jZTogJ2lmLW1vZGlmaWVkLXNpbmNlJyxcbiAgLyoqXG4gICAqIGBgYHR4dFxuICAgKiBMYXN0LU1vZGlmaWVkOiA8ZGF5LW5hbWU+LCA8ZGF5PiA8bW9udGg+IDx5ZWFyPiA8aG91cj46PG1pbnV0ZT46PHNlY29uZD4gR01UXG4gICAqIGBgYFxuICAgKlxuICAgKiBAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvTGFzdC1Nb2RpZmllZFxuICAgKi9cbiAgTGFzdE1vZGlmaWVkOiAnbGFzdC1tb2RpZmllZCcsXG4gIC8qKlxuICAgKiBgYGB0eHRcbiAgICogSWYtTm9uZS1NYXRjaDogXCI8ZXRhZ192YWx1ZT5cIlxuICAgKiBJZi1Ob25lLU1hdGNoOiBcIjxldGFnX3ZhbHVlPlwiLCBcIjxldGFnX3ZhbHVlPlwiLCDigKZcbiAgICogSWYtTm9uZS1NYXRjaDogKlxuICAgKiBgYGBcbiAgICpcbiAgICogQGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0lmLU5vbmUtTWF0Y2hcbiAgICovXG4gIElmTm9uZU1hdGNoOiAnaWYtbm9uZS1tYXRjaCcsXG4gIC8qKlxuICAgKiBgYGB0eHRcbiAgICogQ2FjaGUtQ29udHJvbDogbWF4LWFnZT02MDQ4MDBcbiAgICogYGBgXG4gICAqXG4gICAqIEBsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9DYWNoZS1Db250cm9sXG4gICAqL1xuICBDYWNoZUNvbnRyb2w6ICdjYWNoZS1jb250cm9sJyxcbiAgLyoqXG4gICAqIGBgYHR4dFxuICAgKiBQcmFnbWE6IG5vIC0gY2FjaGU7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvUHJhZ21hXG4gICAqL1xuICBQcmFnbWE6ICdwcmFnbWEnLFxuICAvKipcbiAgICogYGBgdHh0XG4gICAqIEVUYWc6IFcgLyAnPGV0YWdfdmFsdWU+JztcbiAgICogRVRhZzogJzxldGFnX3ZhbHVlPic7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvRVRhZ1xuICAgKi9cbiAgRVRhZzogJ2V0YWcnLFxuICAvKipcbiAgICogYGBgdHh0XG4gICAqIEV4cGlyZXM6IDxodHRwLWRhdGU+XG4gICAqIGBgYFxuICAgKlxuICAgKiBAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvRXhwaXJlc1xuICAgKi9cbiAgRXhwaXJlczogJ2V4cGlyZXMnLFxuICAvKipcbiAgICogYGBgdHh0XG4gICAqIEFnZTogPGRlbHRhLXNlY29uZHM+XG4gICAqIGBgYFxuICAgKlxuICAgKiBAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvQWdlXG4gICAqL1xuICBBZ2U6ICdhZ2UnLFxuICAvKipcbiAgICogVXNlZCBpbnRlcm5hbGx5IGFzIG1ldGFkYXRhIHRvIG1hcmsgdGhlIGNhY2hlIGl0ZW0gYXMgcmV2YWxpZGF0YWJsZSBhbmQgZW5hYmxpbmdcbiAgICogc3RhbGUgY2FjaGUgc3RhdGUgQ29udGFpbnMgYSBzdHJpbmcgb2YgQVNDSUkgY2hhcmFjdGVycyB0aGF0IGNhbiBiZSB1c2VkIGFzIEVUYWcgZm9yXG4gICAqIGBJZi1NYXRjaGAgaGVhZGVyIFByb3ZpZGVkIGJ5IHVzZXIgdXNpbmcgYGNhY2hlLmV0YWdgIHZhbHVlLlxuICAgKlxuICAgKiBgYGB0eHRcbiAgICogWC1BeGlvcy1DYWNoZS1FdGFnOiBcIjxldGFnX3ZhbHVlPlwiXG4gICAqIGBgYFxuICAgKi9cbiAgWEF4aW9zQ2FjaGVFdGFnOiAneC1heGlvcy1jYWNoZS1ldGFnJyxcbiAgLyoqXG4gICAqIFVzZWQgaW50ZXJuYWxseSBhcyBtZXRhZGF0YSB0byBtYXJrIHRoZSBjYWNoZSBpdGVtIGFzIHJldmFsaWRhdGFibGUgYW5kIGVuYWJsaW5nXG4gICAqIHN0YWxlIGNhY2hlIHN0YXRlIG1heSBjb250YWluIGAndXNlLWNhY2hlLXRpbWVzdGFtcCdgIGlmIGBjYWNoZS5tb2RpZmllZFNpbmNlYCBpc1xuICAgKiBgdHJ1ZWAsIG90aGVyd2lzZSB3aWxsIGNvbnRhaW4gYSBkYXRlIGZyb20gYGNhY2hlLm1vZGlmaWVkU2luY2VgLiBJZiBhIGRhdGUgaXNcbiAgICogcHJvdmlkZWQsIGl0IGNhbiBiZSB1c2VkIGZvciBgSWYtTW9kaWZpZWQtU2luY2VgIGhlYWRlciwgb3RoZXJ3aXNlIHRoZSBjYWNoZVxuICAgKiB0aW1lc3RhbXAgY2FuIGJlIHVzZWQgZm9yIGBJZi1Nb2RpZmllZC1TaW5jZWAgaGVhZGVyLlxuICAgKlxuICAgKiBgYGB0eHRcbiAgICogWC1BeGlvcy1DYWNoZS1MYXN0LU1vZGlmaWVkOiA8ZGF5LW5hbWU+LCA8ZGF5PiA8bW9udGg+IDx5ZWFyPiA8aG91cj46PG1pbnV0ZT46PHNlY29uZD4gR01UXG4gICAqIFgtQXhpb3MtQ2FjaGUtTGFzdC1Nb2RpZmllZDogdXNlLWNhY2hlLXRpbWVzdGFtcFxuICAgKiBgYGBcbiAgICovXG4gIFhBeGlvc0NhY2hlTGFzdE1vZGlmaWVkOiAneC1heGlvcy1jYWNoZS1sYXN0LW1vZGlmaWVkJyxcbiAgLyoqXG4gICAqIFVzZWQgaW50ZXJuYWxseSBhcyBtZXRhZGF0YSB0byBtYXJrIHRoZSBjYWNoZSBpdGVtIGFibGUgdG8gYmUgdXNlZCBpZiB0aGUgc2VydmVyXG4gICAqIHJldHVybnMgYW4gZXJyb3IuIFRoZSBzdGFsZS1pZi1lcnJvciByZXNwb25zZSBkaXJlY3RpdmUgaW5kaWNhdGVzIHRoYXQgdGhlIGNhY2hlIGNhblxuICAgKiByZXVzZSBhIHN0YWxlIHJlc3BvbnNlIHdoZW4gYW55IGVycm9yIG9jY3Vycy5cbiAgICpcbiAgICogYGBgdHh0XG4gICAqIFhBeGlvc0NhY2hlU3RhbGVJZkVycm9yOiA8c2Vjb25kcz5cbiAgICogYGBgXG4gICAqL1xuICBYQXhpb3NDYWNoZVN0YWxlSWZFcnJvcjogJ3gtYXhpb3MtY2FjaGUtc3RhbGUtaWYtZXJyb3InXG59KTtcblxuY29uc3QgZGVmYXVsdEhlYWRlckludGVycHJldGVyID0gKGhlYWRlcnMsIGxvY2F0aW9uKSA9PiB7XG4gIGlmICghaGVhZGVycykgcmV0dXJuICdub3QgZW5vdWdoIGhlYWRlcnMnO1xuICBjb25zdCBjYWNoZUNvbnRyb2wgPSBoZWFkZXJzW0hlYWRlci5DYWNoZUNvbnRyb2xdO1xuICBpZiAoY2FjaGVDb250cm9sKSB7XG4gICAgY29uc3QgY2MgPSBwYXJzZShTdHJpbmcoY2FjaGVDb250cm9sKSk7XG4gICAgaWYgKFxuICAgIC8vIEhlYWRlciB0b2xkIHRoYXQgdGhpcyByZXNwb25zZSBzaG91bGQgbm90IGJlIGNhY2hlZC5cbiAgICBjYy5ub0NhY2hlIHx8IGNjLm5vU3RvcmUgfHxcbiAgICAvLyBTZXJ2ZXIgc2lkZSBoYW5kbGluZyBwcml2YXRlIGRhdGFcbiAgICBsb2NhdGlvbiA9PT0gJ3NlcnZlcicgJiYgY2MucHJpdmF0ZSkge1xuICAgICAgcmV0dXJuICdkb250IGNhY2hlJztcbiAgICB9XG4gICAgaWYgKGNjLmltbXV0YWJsZSkge1xuICAgICAgLy8gMSB5ZWFyIGlzIHN1ZmZpY2llbnQsIGFzIEluZmluaXR5IG1heSBjYXVzZSBwcm9ibGVtcyB3aXRoIGNlcnRhaW4gc3RvcmFnZXMuXG4gICAgICAvLyBJdCBtaWdodCBub3QgYmUgdGhlIGJlc3Qgd2F5LCBidXQgYSB5ZWFyIGlzIGJldHRlciB0aGFuIG5vbmUuIEZhY2Vib29rIHNob3dzXG4gICAgICAvLyB0aGF0IGEgYnJvd3NlciBzZXNzaW9uIHN0YXlzIGF0IHRoZSBtb3N0IDEgbW9udGguXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjYWNoZTogMTAwMCAqIDYwICogNjAgKiAyNCAqIDM2NVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGNjLm1heEFnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBhZ2UgPSBoZWFkZXJzW0hlYWRlci5BZ2VdO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2FjaGU6IGFnZSA/XG4gICAgICAgIC8vIElmIGFnZSBpcyBwcmVzZW50LCB3ZSBtdXN0IHN1YnRyYWN0IGl0IGZyb20gbWF4QWdlXG4gICAgICAgIChjYy5tYXhBZ2UgLSBOdW1iZXIoYWdlKSkgKiAxMDAwIDogY2MubWF4QWdlICogMTAwMCxcbiAgICAgICAgLy8gQWxyZWFkeSBvdXQgb2YgZGF0ZSwgbXVzdCBiZSByZXF1ZXN0ZWQgYWdhaW5cbiAgICAgICAgc3RhbGU6XG4gICAgICAgIC8vIEkgY291bGRuJ3QgZmluZCBhbnkgZG9jdW1lbnRhdGlvbiBhYm91dCB3aG8gc2hvdWxkIGJlIHVzZWQsIGFzIHRoZXlcbiAgICAgICAgLy8gYXJlIG5vdCBtZWFudCB0byBvdmVybGFwIGVhY2ggb3RoZXIuIEJ1dCwgYXMgd2UgY2Fubm90IHJlcXVlc3QgaW4gdGhlXG4gICAgICAgIC8vIGJhY2tncm91bmQsIGFzIHRoZSBzdGFsZS13aGlsZS1yZXZhbGlkYXRlIHNheXMsIGFuZCB3ZSBqdXN0IGluY3JlYXNlXG4gICAgICAgIC8vIGl0cyBzdGFsZVR0bCB3aGVuIGl0cyBwcmVzZW50LCBtYXgtc3RhbGUgaXMgYmVpbmcgcHJlZmVycmVkIG92ZXJcbiAgICAgICAgLy8gc3RhbGUtd2hpbGUtcmV2YWxpZGF0ZS5cbiAgICAgICAgY2MubWF4U3RhbGUgIT09IHVuZGVmaW5lZCA/IGNjLm1heFN0YWxlICogMTAwMCA6IGNjLnN0YWxlV2hpbGVSZXZhbGlkYXRlICE9PSB1bmRlZmluZWQgPyBjYy5zdGFsZVdoaWxlUmV2YWxpZGF0ZSAqIDEwMDAgOiB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIGNvbnN0IGV4cGlyZXMgPSBoZWFkZXJzW0hlYWRlci5FeHBpcmVzXTtcbiAgaWYgKGV4cGlyZXMpIHtcbiAgICBjb25zdCBtaWxsaXNlY29uZHMgPSBEYXRlLnBhcnNlKFN0cmluZyhleHBpcmVzKSkgLSBEYXRlLm5vdygpO1xuICAgIHJldHVybiBtaWxsaXNlY29uZHMgPj0gMCA/IHtcbiAgICAgIGNhY2hlOiBtaWxsaXNlY29uZHNcbiAgICB9IDogJ2RvbnQgY2FjaGUnO1xuICB9XG4gIHJldHVybiAnbm90IGVub3VnaCBoZWFkZXJzJztcbn07XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG4vKiogVGVzdHMgYW4gcmVzcG9uc2UgYWdhaW5zdCBhIHtAbGluayBDYWNoZVByZWRpY2F0ZU9iamVjdH0uICovXG5hc3luYyBmdW5jdGlvbiB0ZXN0Q2FjaGVQcmVkaWNhdGUocmVzcG9uc2UsIHByZWRpY2F0ZSkge1xuICBpZiAodHlwZW9mIHByZWRpY2F0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBwcmVkaWNhdGUocmVzcG9uc2UpO1xuICB9XG4gIGNvbnN0IHtcbiAgICBzdGF0dXNDaGVjayxcbiAgICByZXNwb25zZU1hdGNoLFxuICAgIGNvbnRhaW5zSGVhZGVyc1xuICB9ID0gcHJlZGljYXRlO1xuICBpZiAoc3RhdHVzQ2hlY2sgJiYgIShhd2FpdCBzdGF0dXNDaGVjayhyZXNwb25zZS5zdGF0dXMpKSB8fCByZXNwb25zZU1hdGNoICYmICEoYXdhaXQgcmVzcG9uc2VNYXRjaChyZXNwb25zZSkpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChjb250YWluc0hlYWRlcnMpIHtcbiAgICBmb3IgKGNvbnN0IFtoZWFkZXIsIF9wcmVkaWNhdGVdIG9mIE9iamVjdC5lbnRyaWVzKGNvbnRhaW5zSGVhZGVycykpIHtcbiAgICAgIHZhciBfcmVzcG9uc2UkaGVhZGVycyRoZWE7XG4gICAgICBpZiAoIShhd2FpdCBfcHJlZGljYXRlKCAvLyBBdm9pZCBidWdzIGluIGNhc2UgdGhlIGhlYWRlciBpcyBub3QgaW4gbG93ZXIgY2FzZVxuICAgICAgKF9yZXNwb25zZSRoZWFkZXJzJGhlYSA9IHJlc3BvbnNlLmhlYWRlcnNbaGVhZGVyLnRvTG93ZXJDYXNlKCldKSAhPSBudWxsID8gX3Jlc3BvbnNlJGhlYWRlcnMkaGVhIDogcmVzcG9uc2UuaGVhZGVyc1toZWFkZXJdKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgZ2l2ZW4gVVJMIG1hdGNoZXMgYSBzcGVjaWZpZWQgcGF0dGVybiwgd2hpY2ggY2FuIGJlIGVpdGhlciBhIHN0cmluZyBvciBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAqXG4gKiBAcGFyYW0gbWF0Y2hQYXR0ZXJuIC0gVGhlIHBhdHRlcm4gdG8gbWF0Y2ggYWdhaW5zdFxuICogICAtIElmIGl0J3MgYSByZWd1bGFyIGV4cHJlc3Npb24sIGl0IHdpbGwgYmUgcmVzZXQgdG8gZW5zdXJlIGNvbnNpc3RlbnQgYmVoYXZpb3IgZm9yIHN0YXRlZnVsIHJlZ3VsYXIgZXhwcmVzc2lvbnMuXG4gKiAgIC0gSWYgaXQncyBhIHN0cmluZywgdGhlIGZ1bmN0aW9uIGNoZWNrcyBpZiB0aGUgVVJMIGNvbnRhaW5zIHRoZSBzdHJpbmcuXG4gKiBAcGFyYW0gY29uZmlnVXJsIC0gVGhlIFVSTCB0byB0ZXN0IGFnYWluc3QgdGhlIHByb3ZpZGVkIHBhdHRlcm47IG5vcm1hbGx5IGBjb25maWcudXJsYC5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgYGNvbmZpZ1VybGAgbWF0Y2hlcyB0aGUgYG1hdGNoUGF0dGVybmBcbiAqL1xuZnVuY3Rpb24gcmVnZXhPclN0cmluZ01hdGNoKG1hdGNoUGF0dGVybiwgY29uZmlnVXJsKSB7XG4gIGlmIChtYXRjaFBhdHRlcm4gaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICBtYXRjaFBhdHRlcm4ubGFzdEluZGV4ID0gMDsgLy8gUmVzZXQgdGhlIHJlZ2V4IHRvIGVuc3VyZSBjb25zaXN0ZW50IG1hdGNoaW5nXG4gICAgcmV0dXJuIG1hdGNoUGF0dGVybi50ZXN0KGNvbmZpZ1VybCk7XG4gIH1cbiAgcmV0dXJuIGNvbmZpZ1VybC5pbmNsdWRlcyhtYXRjaFBhdHRlcm4pO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmFsaWRhdGVTdGF0dXMgZnVuY3Rpb24gdGhhdCB3aWxsIHVzZSB0aGUgb25lIGFscmVhZHkgdXNlZCBhbmQgYWxzb1xuICogYWNjZXB0IHN0YXR1cyBjb2RlIDMwNC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVmFsaWRhdGVTdGF0dXMob2xkVmFsaWRhdGUpIHtcbiAgcmV0dXJuIG9sZFZhbGlkYXRlID8gc3RhdHVzID0+IG9sZFZhbGlkYXRlKHN0YXR1cykgfHwgc3RhdHVzID09PSAzMDQgOiBzdGF0dXMgPT4gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgfHwgc3RhdHVzID09PSAzMDQ7XG59XG4vKiogQ2hlY2tzIGlmIHRoZSBnaXZlbiBtZXRob2QgaXMgaW4gdGhlIG1ldGhvZHMgYXJyYXkgKi9cbmZ1bmN0aW9uIGlzTWV0aG9kSW4ocmVxdWVzdE1ldGhvZCA9ICdnZXQnLCBtZXRob2RMaXN0ID0gW10pIHtcbiAgcmVxdWVzdE1ldGhvZCA9IHJlcXVlc3RNZXRob2QudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIG1ldGhvZExpc3Quc29tZShtZXRob2QgPT4gbWV0aG9kID09PSByZXF1ZXN0TWV0aG9kKTtcbn1cbi8qKlxuICogVGhpcyBmdW5jdGlvbiB1cGRhdGVzIHRoZSBjYWNoZSB3aGVuIHRoZSByZXF1ZXN0IGlzIHN0YWxlLiBTbywgdGhlIG5leHQgcmVxdWVzdCB0byB0aGVcbiAqIHNlcnZlciB3aWxsIGJlIG1hZGUgd2l0aCBwcm9wZXIgaGVhZGVyIC8gc2V0dGluZ3MuXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZVN0YWxlUmVxdWVzdChjYWNoZSwgY29uZmlnKSB7XG4gIGNvbmZpZy5oZWFkZXJzIHx8IChjb25maWcuaGVhZGVycyA9IHt9KTtcbiAgY29uc3Qge1xuICAgIGV0YWcsXG4gICAgbW9kaWZpZWRTaW5jZVxuICB9ID0gY29uZmlnLmNhY2hlO1xuICBpZiAoZXRhZykge1xuICAgIHZhciBfY2FjaGUkZGF0YTtcbiAgICBjb25zdCBldGFnVmFsdWUgPSBldGFnID09PSB0cnVlID8gKF9jYWNoZSRkYXRhID0gY2FjaGUuZGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jYWNoZSRkYXRhLmhlYWRlcnNbSGVhZGVyLkVUYWddIDogZXRhZztcbiAgICBpZiAoZXRhZ1ZhbHVlKSB7XG4gICAgICBjb25maWcuaGVhZGVyc1tIZWFkZXIuSWZOb25lTWF0Y2hdID0gZXRhZ1ZhbHVlO1xuICAgIH1cbiAgfVxuICBpZiAobW9kaWZpZWRTaW5jZSkge1xuICAgIGNvbmZpZy5oZWFkZXJzW0hlYWRlci5JZk1vZGlmaWVkU2luY2VdID0gbW9kaWZpZWRTaW5jZSA9PT0gdHJ1ZSA/XG4gICAgLy8gSWYgbGFzdC1tb2RpZmllZCBpcyBub3QgcHJlc2VudCwgdXNlIHRoZSBjcmVhdGVkQXQgdGltZXN0YW1wXG4gICAgY2FjaGUuZGF0YS5oZWFkZXJzW0hlYWRlci5MYXN0TW9kaWZpZWRdIHx8IG5ldyBEYXRlKGNhY2hlLmNyZWF0ZWRBdCkudG9VVENTdHJpbmcoKSA6IG1vZGlmaWVkU2luY2UudG9VVENTdHJpbmcoKTtcbiAgfVxufVxuLyoqXG4gKiBDcmVhdGVzIHRoZSBuZXcgZGF0ZSB0byB0aGUgY2FjaGUgYnkgdGhlIHByb3ZpZGVkIHJlc3BvbnNlLiBBbHNvIGhhbmRsZXMgcG9zc2libGUgMzA0XG4gKiBOb3QgTW9kaWZpZWQgYnkgdXBkYXRpbmcgcmVzcG9uc2UgcHJvcGVydGllcy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2FjaGVSZXNwb25zZShyZXNwb25zZSwgcHJldmlvdXNDYWNoZSkge1xuICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAzMDQgJiYgcHJldmlvdXNDYWNoZSkge1xuICAgIC8vIFNldCB0aGUgY2FjaGUgaW5mb3JtYXRpb24gaW50byB0aGUgcmVzcG9uc2Ugb2JqZWN0XG4gICAgcmVzcG9uc2UuY2FjaGVkID0gdHJ1ZTtcbiAgICByZXNwb25zZS5kYXRhID0gcHJldmlvdXNDYWNoZS5kYXRhO1xuICAgIHJlc3BvbnNlLnN0YXR1cyA9IHByZXZpb3VzQ2FjaGUuc3RhdHVzO1xuICAgIHJlc3BvbnNlLnN0YXR1c1RleHQgPSBwcmV2aW91c0NhY2hlLnN0YXR1c1RleHQ7XG4gICAgLy8gVXBkYXRlIHBvc3NpYmxlIG5ldyBoZWFkZXJzXG4gICAgcmVzcG9uc2UuaGVhZGVycyA9IF9leHRlbmRzKHt9LCBwcmV2aW91c0NhY2hlLmhlYWRlcnMsIHJlc3BvbnNlLmhlYWRlcnMpO1xuICAgIC8vIHJldHVybiB0aGUgb2xkIGNhY2hlXG4gICAgcmV0dXJuIHByZXZpb3VzQ2FjaGU7XG4gIH1cbiAgLy8gTmV3IFJlc3BvbnNlXG4gIHJldHVybiB7XG4gICAgZGF0YTogcmVzcG9uc2UuZGF0YSxcbiAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICBzdGF0dXNUZXh0OiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgIGhlYWRlcnM6IHJlc3BvbnNlLmhlYWRlcnNcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFJlcXVlc3RJbnRlcmNlcHRvcihheGlvcykge1xuICBjb25zdCBvbkZ1bGZpbGxlZCA9IGFzeW5jIGNvbmZpZyA9PiB7XG4gICAgY29uZmlnLmlkID0gYXhpb3MuZ2VuZXJhdGVLZXkoY29uZmlnKTtcbiAgICBpZiAoY29uZmlnLmNhY2hlID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG4gICAgLy8gbWVyZ2UgZGVmYXVsdHMgd2l0aCBwZXIgcmVxdWVzdCBjb25maWd1cmF0aW9uXG4gICAgY29uZmlnLmNhY2hlID0gX2V4dGVuZHMoe30sIGF4aW9zLmRlZmF1bHRzLmNhY2hlLCBjb25maWcuY2FjaGUpO1xuICAgIC8vIGlnbm9yZVVybHMgKGJsYWNrbGlzdClcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5jYWNoZS5jYWNoZVByZWRpY2F0ZSA9PT0gJ29iamVjdCcgJiYgY29uZmlnLmNhY2hlLmNhY2hlUHJlZGljYXRlLmlnbm9yZVVybHMgJiYgY29uZmlnLnVybCkge1xuICAgICAgZm9yIChjb25zdCB1cmwgb2YgY29uZmlnLmNhY2hlLmNhY2hlUHJlZGljYXRlLmlnbm9yZVVybHMpIHtcbiAgICAgICAgaWYgKHJlZ2V4T3JTdHJpbmdNYXRjaCh1cmwsIGNvbmZpZy51cmwpKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBhbGxvd1VybHNcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5jYWNoZS5jYWNoZVByZWRpY2F0ZSA9PT0gJ29iamVjdCcgJiYgY29uZmlnLmNhY2hlLmNhY2hlUHJlZGljYXRlLmFsbG93VXJscyAmJiBjb25maWcudXJsKSB7XG4gICAgICBsZXQgbWF0Y2hlZCA9IGZhbHNlO1xuICAgICAgZm9yIChjb25zdCB1cmwgb2YgY29uZmlnLmNhY2hlLmNhY2hlUHJlZGljYXRlLmFsbG93VXJscykge1xuICAgICAgICBpZiAocmVnZXhPclN0cmluZ01hdGNoKHVybCwgY29uZmlnLnVybCkpIHtcbiAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFtYXRjaGVkKSB7XG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEFwcGxpZXMgc3VmZmljaWVudCBoZWFkZXJzIHRvIHByZXZlbnQgb3RoZXIgY2FjaGUgc3lzdGVtcyB0byB3b3JrIGFsb25nIHdpdGggdGhpcyBvbmVcbiAgICAvL1xuICAgIC8vIEl0cyBjdXJyZW50bHkgdXNlZCBiZWZvcmUgaXNNZXRob2RJbiBiZWNhdXNlIGlmIHRoZSBpc01ldGhvZEluIHJldHVybnMgZmFsc2UsIHRoZSByZXF1ZXN0XG4gICAgLy8gc2hvdWxkbid0IGJlIGNhY2hlZCBhbiB0aGVyZWZvcmUgbmVpdGhlciBpbiB0aGUgYnJvd3Nlci5cbiAgICBpZiAoY29uZmlnLmNhY2hlLmNhY2hlVGFrZW92ZXIpIHtcbiAgICAgIHZhciBfY29uZmlnJGhlYWRlcnMsIF9IZWFkZXIkQ2FjaGVDb250cm9sLCBfY29uZmlnJGhlYWRlcnMkX0hlYWQsIF9jb25maWckaGVhZGVyczIsIF9IZWFkZXIkUHJhZ21hLCBfY29uZmlnJGhlYWRlcnMyJF9IZWEsIF9jb25maWckaGVhZGVyczMsIF9IZWFkZXIkRXhwaXJlcywgX2NvbmZpZyRoZWFkZXJzMyRfSGVhO1xuICAgICAgKF9jb25maWckaGVhZGVycyRfSGVhZCA9IChfY29uZmlnJGhlYWRlcnMgPSBjb25maWcuaGVhZGVycylbX0hlYWRlciRDYWNoZUNvbnRyb2wgPSBIZWFkZXIuQ2FjaGVDb250cm9sXSkgIT0gbnVsbCA/IF9jb25maWckaGVhZGVycyRfSGVhZCA6IF9jb25maWckaGVhZGVyc1tfSGVhZGVyJENhY2hlQ29udHJvbF0gPSAnbm8tY2FjaGUnO1xuICAgICAgKF9jb25maWckaGVhZGVyczIkX0hlYSA9IChfY29uZmlnJGhlYWRlcnMyID0gY29uZmlnLmhlYWRlcnMpW19IZWFkZXIkUHJhZ21hID0gSGVhZGVyLlByYWdtYV0pICE9IG51bGwgPyBfY29uZmlnJGhlYWRlcnMyJF9IZWEgOiBfY29uZmlnJGhlYWRlcnMyW19IZWFkZXIkUHJhZ21hXSA9ICduby1jYWNoZSc7XG4gICAgICAoX2NvbmZpZyRoZWFkZXJzMyRfSGVhID0gKF9jb25maWckaGVhZGVyczMgPSBjb25maWcuaGVhZGVycylbX0hlYWRlciRFeHBpcmVzID0gSGVhZGVyLkV4cGlyZXNdKSAhPSBudWxsID8gX2NvbmZpZyRoZWFkZXJzMyRfSGVhIDogX2NvbmZpZyRoZWFkZXJzM1tfSGVhZGVyJEV4cGlyZXNdID0gJzAnO1xuICAgIH1cbiAgICBpZiAoIWlzTWV0aG9kSW4oY29uZmlnLm1ldGhvZCwgY29uZmlnLmNhY2hlLm1ldGhvZHMpKSB7XG4gICAgICByZXR1cm4gY29uZmlnO1xuICAgIH1cbiAgICAvLyBBc3N1bWVzIHRoYXQgdGhlIHN0b3JhZ2UgaGFuZGxlZCBzdGFsZWQgcmVzcG9uc2VzXG4gICAgbGV0IGNhY2hlID0gYXdhaXQgYXhpb3Muc3RvcmFnZS5nZXQoY29uZmlnLmlkLCBjb25maWcpO1xuICAgIGNvbnN0IG92ZXJyaWRlQ2FjaGUgPSBjb25maWcuY2FjaGUub3ZlcnJpZGU7XG4gICAgLy8gTm90IGNhY2hlZCwgY29udGludWUgdGhlIHJlcXVlc3QsIGFuZCBtYXJrIGl0IGFzIGZldGNoaW5nXG4gICAgLy8gYmlvbWUtaWdub3JlIGxpbnQvc3VzcGljaW91cy9ub0NvbmZ1c2luZ0xhYmVsczogcmVxdWlyZWQgdG8gYnJlYWsgY29uZGl0aW9uIGluIHNpbXVsdGFuZW91cyBhY2Nlc3Nlc1xuICAgIGlnbm9yZUFuZFJlcXVlc3Q6IGlmIChjYWNoZS5zdGF0ZSA9PT0gJ2VtcHR5JyB8fCBjYWNoZS5zdGF0ZSA9PT0gJ3N0YWxlJyB8fCBjYWNoZS5zdGF0ZSA9PT0gJ211c3QtcmV2YWxpZGF0ZScgfHwgb3ZlcnJpZGVDYWNoZSkge1xuICAgICAgLy8gVGhpcyBjaGVja3MgZm9yIHNpbXVsdGFuZW91cyBhY2Nlc3MgdG8gYSBuZXcga2V5LiBUaGUganMgZXZlbnQgbG9vcCBqdW1wcyBvbiB0aGVcbiAgICAgIC8vIGZpcnN0IGF3YWl0IHN0YXRlbWVudCwgc28gdGhlIHNlY29uZCAoYXN5bmNocm9ub3VzIGNhbGwpIHJlcXVlc3QgbWF5IGhhdmUgYWxyZWFkeVxuICAgICAgLy8gc3RhcnRlZCBleGVjdXRpbmcuXG4gICAgICBpZiAoYXhpb3Mud2FpdGluZy5oYXMoY29uZmlnLmlkKSAmJiAhb3ZlcnJpZGVDYWNoZSkge1xuICAgICAgICBjYWNoZSA9IGF3YWl0IGF4aW9zLnN0b3JhZ2UuZ2V0KGNvbmZpZy5pZCwgY29uZmlnKTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUaGlzIGNoZWNrIGlzIHJlcXVpcmVkIHdoZW4gYSByZXF1ZXN0IGhhcyBpdCBvd24gY2FjaGUgZGVsZXRlZCBtYW51YWxseSwgbGV0c1xuICAgICAgICAvLyBzYXkgYnkgYSBgYXhpb3Muc3RvcmFnZS5kZWxldGUoa2V5KWAgYW5kIGhhcyBhIGNvbmN1cnJlbnQgbG9hZGluZyByZXF1ZXN0LlxuICAgICAgICAvLyBCZWNhdXNlIGluIHRoaXMgY2FzZSwgdGhlIGNhY2hlIHdpbGwgYmUgZW1wdHkgYW5kIG1heSBzdGlsbCBoYXMgYSBwZW5kaW5nIGtleVxuICAgICAgICAvLyBvbiB3YWl0aW5nIG1hcC5cbiAgICAgICAgaWYgKGNhY2hlLnN0YXRlICE9PSAnZW1wdHknICYmIGNhY2hlLnN0YXRlICE9PSAnbXVzdC1yZXZhbGlkYXRlJykge1xuICAgICAgICAgIGJyZWFrIGlnbm9yZUFuZFJlcXVlc3Q7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIENyZWF0ZSBhIGRlZmVycmVkIHRvIHJlc29sdmUgb3RoZXIgcmVxdWVzdHMgZm9yIHRoZSBzYW1lIGtleSB3aGVuIGl0J3MgY29tcGxldGVkXG4gICAgICBjb25zdCBkZWYgPSBkZWZlcnJlZCgpO1xuICAgICAgYXhpb3Mud2FpdGluZy5zZXQoY29uZmlnLmlkLCBkZWYpO1xuICAgICAgLy8gQWRkcyBhIGRlZmF1bHQgcmVqZWN0IGhhbmRsZXIgdG8gY2F0Y2ggd2hlbiB0aGUgcmVxdWVzdCBnZXRzIGFib3J0ZWQgd2l0aG91dFxuICAgICAgLy8gb3RoZXJzIHdhaXRpbmcgZm9yIGl0LlxuICAgICAgZGVmLmNhdGNoKCgpID0+IHVuZGVmaW5lZCk7XG4gICAgICBhd2FpdCBheGlvcy5zdG9yYWdlLnNldChjb25maWcuaWQsIHtcbiAgICAgICAgc3RhdGU6ICdsb2FkaW5nJyxcbiAgICAgICAgcHJldmlvdXM6IG92ZXJyaWRlQ2FjaGUgP1xuICAgICAgICAvLyBTaW1wbHkgZGV0ZXJtaW5lIGlmIHRoZSByZXF1ZXN0IGlzIHN0YWxlIG9yIG5vdFxuICAgICAgICAvLyBiYXNlZCBpZiBpdCBoYWQgcHJldmlvdXMgZGF0YSBvciBub3RcbiAgICAgICAgY2FjaGUuZGF0YSA/ICdzdGFsZScgOiAnZW1wdHknIDpcbiAgICAgICAgLy8gVHlwZXNjcmlwdCBkb2Vzbid0IGtub3cgdGhhdCBjYWNoZS5zdGF0ZSBoZXJlIGNhbiBvbmx5IGJlICdlbXB0eScgb3IgJ3N0YWxlJ1xuICAgICAgICBjYWNoZS5zdGF0ZSxcbiAgICAgICAgZGF0YTogY2FjaGUuZGF0YSxcbiAgICAgICAgLy8gSWYgdGhlIGNhY2hlIGlzIGVtcHR5IGFuZCBhc2tlZCB0byBvdmVycmlkZSBpdCwgdXNlIHRoZSBjdXJyZW50IHRpbWVzdGFtcFxuICAgICAgICBjcmVhdGVkQXQ6IG92ZXJyaWRlQ2FjaGUgJiYgIWNhY2hlLmNyZWF0ZWRBdCA/IERhdGUubm93KCkgOiBjYWNoZS5jcmVhdGVkQXRcbiAgICAgIH0sIGNvbmZpZyk7XG4gICAgICBpZiAoY2FjaGUuc3RhdGUgPT09ICdzdGFsZScgfHwgY2FjaGUuc3RhdGUgPT09ICdtdXN0LXJldmFsaWRhdGUnKSB7XG4gICAgICAgIHVwZGF0ZVN0YWxlUmVxdWVzdChjYWNoZSwgY29uZmlnKTtcbiAgICAgIH1cbiAgICAgIGNvbmZpZy52YWxpZGF0ZVN0YXR1cyA9IGNyZWF0ZVZhbGlkYXRlU3RhdHVzKGNvbmZpZy52YWxpZGF0ZVN0YXR1cyk7XG4gICAgICAvLyBIeWRyYXRlcyBhbnkgVUkgdGVtcG9yYXJpbHksIGlmIGNhY2hlIGlzIGF2YWlsYWJsZVxuICAgICAgaWYgKGNhY2hlLnN0YXRlID09PSAnc3RhbGUnIHx8IGNhY2hlLmRhdGEgJiYgY2FjaGUuc3RhdGUgIT09ICdtdXN0LXJldmFsaWRhdGUnKSB7XG4gICAgICAgIGF3YWl0IChjb25maWcuY2FjaGUuaHlkcmF0ZSA9PSBudWxsID8gdm9pZCAwIDogY29uZmlnLmNhY2hlLmh5ZHJhdGUoY2FjaGUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuICAgIGxldCBjYWNoZWRSZXNwb25zZTtcbiAgICBpZiAoY2FjaGUuc3RhdGUgPT09ICdsb2FkaW5nJykge1xuICAgICAgY29uc3QgZGVmZXJyZWQgPSBheGlvcy53YWl0aW5nLmdldChjb25maWcuaWQpO1xuICAgICAgLy8gVGhlIGRlZmVycmVkIG1heSBub3QgZXhpc3RzIHdoZW4gdGhlIHByb2Nlc3MgaXMgdXNpbmcgYSBwZXJzaXN0ZW50XG4gICAgICAvLyBzdG9yYWdlIGFuZCBjYW5jZWxsZWQgIGluIHRoZSBtaWRkbGUgb2YgYSByZXF1ZXN0LCB0aGlzIHdvdWxkIHJlc3VsdCBpblxuICAgICAgLy8gYSBwZW5kaW5nIGxvYWRpbmcgc3RhdGUgaW4gdGhlIHN0b3JhZ2UgYnV0IG5vIGN1cnJlbnQgcHJvbWlzZXMgdG8gcmVzb2x2ZVxuICAgICAgaWYgKCFkZWZlcnJlZCkge1xuICAgICAgICAvLyBIeWRyYXRlcyBhbnkgVUkgdGVtcG9yYXJpbHksIGlmIGNhY2hlIGlzIGF2YWlsYWJsZVxuICAgICAgICBpZiAoY2FjaGUuZGF0YSkge1xuICAgICAgICAgIGF3YWl0IChjb25maWcuY2FjaGUuaHlkcmF0ZSA9PSBudWxsID8gdm9pZCAwIDogY29uZmlnLmNhY2hlLmh5ZHJhdGUoY2FjaGUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gRGVmZXJyZWQgY2FuJ3QgcmV1c2UgdGhlIHZhbHVlIGJlY2F1c2UgdGhlIHVzZXIncyBzdG9yYWdlIG1pZ2h0IGNsb25lXG4gICAgICAgIC8vIG9yIG11dGF0ZSB0aGUgdmFsdWUsIHNvIHdlIG5lZWQgdG8gYXNrIGl0IGFnYWluLlxuICAgICAgICAvLyBGb3IgZXhhbXBsZSB3aXRoIG1lbW9yeVN0b3JhZ2UgKyBjbG9uZURhdGFcbiAgICAgICAgYXdhaXQgZGVmZXJyZWQ7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gYXdhaXQgYXhpb3Muc3RvcmFnZS5nZXQoY29uZmlnLmlkLCBjb25maWcpO1xuICAgICAgICAvLyBUaGlzIGlzIGEgY2FjaGUgbWlzbWF0Y2ggYW5kIHNob3VsZCBuZXZlciBoYXBwZW4sIGJ1dCBpbiBjYXNlIGl0IGRvZXMsXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gcmVkbyB0aGUgcmVxdWVzdCBhbGwgb3ZlciBhZ2Fpbi5cbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGlmICghc3RhdGUuZGF0YSkge1xuICAgICAgICAgIGlmIChmYWxzZSkgO1xuICAgICAgICAgIHJldHVybiBvbkZ1bGZpbGxlZChjb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGM4IGlnbm9yZSBlbmQgKi9cbiAgICAgICAgY2FjaGVkUmVzcG9uc2UgPSBzdGF0ZS5kYXRhO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIEh5ZHJhdGVzIGFueSBVSSB0ZW1wb3JhcmlseSwgaWYgY2FjaGUgaXMgYXZhaWxhYmxlXG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAoY2FjaGUuZGF0YSkge1xuICAgICAgICAgIGF3YWl0IChjb25maWcuY2FjaGUuaHlkcmF0ZSA9PSBudWxsID8gdm9pZCAwIDogY29uZmlnLmNhY2hlLmh5ZHJhdGUoY2FjaGUpKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBjOCBpZ25vcmUgZW5kICovXG4gICAgICAgIC8vIFRoZSBkZWZlcnJlZCBpcyByZWplY3RlZCB3aGVuIHRoZSByZXF1ZXN0IHRoYXQgd2UgYXJlIHdhaXRpbmcgcmVqZWN0cyBpdHMgY2FjaGUuXG4gICAgICAgIC8vIEluIHRoaXMgY2FzZSwgd2UgbmVlZCB0byByZWRvIHRoZSByZXF1ZXN0IGFsbCBvdmVyIGFnYWluLlxuICAgICAgICByZXR1cm4gb25GdWxmaWxsZWQoY29uZmlnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY2FjaGVkUmVzcG9uc2UgPSBjYWNoZS5kYXRhO1xuICAgIH1cbiAgICAvLyBUaGUgY2FjaGVkIGRhdGEgaXMgYWxyZWFkeSB0cmFuc2Zvcm1lZCBhZnRlciByZWNlaXZpbmcgdGhlIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlci5cbiAgICAvLyBSZWFwcGx5aW5nIHRoZSB0cmFuc2Zvcm1hdGlvbiBvbiB0aGUgdHJhbnNmb3JtZWQgZGF0YSB3aWxsIGhhdmUgYW4gdW5pbnRlbmRlZCBlZmZlY3QuXG4gICAgLy8gU2luY2UgdGhlIGNhY2hlZCBkYXRhIGlzIGFscmVhZHkgaW4gdGhlIGRlc2lyZWQgZm9ybWF0LCB0aGVyZSBpcyBubyBuZWVkIHRvIGFwcGx5IHRoZSB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbiBhZ2Fpbi5cbiAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2UgPSB1bmRlZmluZWQ7XG4gICAgLy8gRXZlbiB0aG91Z2ggdGhlIHJlc3BvbnNlIGludGVyY2VwdG9yIHJlY2VpdmVzIHRoaXMgb25lIGZyb20gaGVyZSxcbiAgICAvLyBpdCBoYXMgYmVlbiBjb25maWd1cmVkIHRvIGlnbm9yZSBjYWNoZWQgcmVzcG9uc2VzID0gdHJ1ZVxuICAgIGNvbmZpZy5hZGFwdGVyID0gZnVuY3Rpb24gY2FjaGVkQWRhcHRlcigpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICBjb25maWcsXG4gICAgICAgIGRhdGE6IGNhY2hlZFJlc3BvbnNlLmRhdGEsXG4gICAgICAgIGhlYWRlcnM6IGNhY2hlZFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgIHN0YXR1czogY2FjaGVkUmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiBjYWNoZWRSZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICBjYWNoZWQ6IHRydWUsXG4gICAgICAgIHN0YWxlOiBjYWNoZS5wcmV2aW91cyA9PT0gJ3N0YWxlJyxcbiAgICAgICAgaWQ6IGNvbmZpZy5pZFxuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gY29uZmlnO1xuICB9O1xuICByZXR1cm4ge1xuICAgIG9uRnVsZmlsbGVkXG4gIH07XG59XG5cbi8qKiBGdW5jdGlvbiB0byB1cGRhdGUgYWxsIGNhY2hlcywgZnJvbSBDYWNoZVByb3BlcnRpZXMudXBkYXRlLCB3aXRoIHRoZSBuZXcgZGF0YS4gKi9cbmFzeW5jIGZ1bmN0aW9uIHVwZGF0ZUNhY2hlKHN0b3JhZ2UsIGRhdGEsIGNhY2hlVXBkYXRlcikge1xuICAvLyBHbG9iYWwgY2FjaGUgdXBkYXRlIGZ1bmN0aW9uLlxuICBpZiAodHlwZW9mIGNhY2hlVXBkYXRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBjYWNoZVVwZGF0ZXIoZGF0YSk7XG4gIH1cbiAgZm9yIChjb25zdCBbY2FjaGVLZXksIHVwZGF0ZXJdIG9mIE9iamVjdC5lbnRyaWVzKGNhY2hlVXBkYXRlcikpIHtcbiAgICBpZiAodXBkYXRlciA9PT0gJ2RlbGV0ZScpIHtcbiAgICAgIGF3YWl0IHN0b3JhZ2UucmVtb3ZlKGNhY2hlS2V5LCBkYXRhLmNvbmZpZyk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSBhd2FpdCBzdG9yYWdlLmdldChjYWNoZUtleSwgZGF0YS5jb25maWcpO1xuICAgIGlmICh2YWx1ZS5zdGF0ZSA9PT0gJ2xvYWRpbmcnKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgbmV3VmFsdWUgPSBhd2FpdCB1cGRhdGVyKHZhbHVlLCBkYXRhKTtcbiAgICBpZiAobmV3VmFsdWUgPT09ICdkZWxldGUnKSB7XG4gICAgICBhd2FpdCBzdG9yYWdlLnJlbW92ZShjYWNoZUtleSwgZGF0YS5jb25maWcpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChuZXdWYWx1ZSAhPT0gJ2lnbm9yZScpIHtcbiAgICAgIGF3YWl0IHN0b3JhZ2Uuc2V0KGNhY2hlS2V5LCBuZXdWYWx1ZSwgZGF0YS5jb25maWcpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0UmVzcG9uc2VJbnRlcmNlcHRvcihheGlvcykge1xuICAvKipcbiAgICogUmVqZWN0cyBjYWNoZSBmb3IgYW4gcmVzcG9uc2UgcmVzcG9uc2UuXG4gICAqXG4gICAqIEFsc28gdXBkYXRlIHRoZSB3YWl0aW5nIGxpc3QgZm9yIHRoaXMga2V5IGJ5IHJlamVjdGluZyBpdC5cbiAgICovXG4gIGNvbnN0IHJlamVjdFJlc3BvbnNlID0gYXN5bmMgKHJlc3BvbnNlSWQsIGNvbmZpZywgY2xlYXJDYWNoZSkgPT4ge1xuICAgIC8vIFVwZGF0ZXMgdGhlIGNhY2hlIHRvIGVtcHR5IHRvIHByZXZlbnQgaW5maW5pdGUgbG9hZGluZyBzdGF0ZVxuICAgIGlmIChjbGVhckNhY2hlKSB7XG4gICAgICBhd2FpdCBheGlvcy5zdG9yYWdlLnJlbW92ZShyZXNwb25zZUlkLCBjb25maWcpO1xuICAgIH1cbiAgICAvLyBSZWplY3RzIHRoZSBkZWZlcnJlZCwgaWYgcHJlc2VudFxuICAgIGNvbnN0IGRlZmVycmVkID0gYXhpb3Mud2FpdGluZy5nZXQocmVzcG9uc2VJZCk7XG4gICAgaWYgKGRlZmVycmVkKSB7XG4gICAgICBkZWZlcnJlZC5yZWplY3QoKTtcbiAgICAgIGF4aW9zLndhaXRpbmcuZGVsZXRlKHJlc3BvbnNlSWQpO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgb25GdWxmaWxsZWQgPSBhc3luYyByZXNwb25zZSA9PiB7XG4gICAgdmFyIF9yZXNwb25zZSRjYWNoZWQ7XG4gICAgLy8gV2hlbiByZXNwb25zZS5jb25maWcgaXMgbm90IHByZXNlbnQsIHRoZSByZXNwb25zZSBpcyBpbmRlZWQgYSBlcnJvci5cbiAgICBpZiAoIShyZXNwb25zZSAhPSBudWxsICYmIHJlc3BvbnNlLmNvbmZpZykpIHtcbiAgICAgIC8vIFJlLXRocm93cyB0aGUgZXJyb3JcbiAgICAgIHRocm93IHJlc3BvbnNlO1xuICAgIH1cbiAgICByZXNwb25zZS5pZCA9IHJlc3BvbnNlLmNvbmZpZy5pZDtcbiAgICAoX3Jlc3BvbnNlJGNhY2hlZCA9IHJlc3BvbnNlLmNhY2hlZCkgIT0gbnVsbCA/IF9yZXNwb25zZSRjYWNoZWQgOiByZXNwb25zZS5jYWNoZWQgPSBmYWxzZTtcbiAgICBjb25zdCBjb25maWcgPSByZXNwb25zZS5jb25maWc7XG4gICAgLy8gUmVxdWVzdCBpbnRlcmNlcHRvciBtZXJnZXMgZGVmYXVsdHMgd2l0aCBwZXIgcmVxdWVzdCBjb25maWd1cmF0aW9uXG4gICAgY29uc3QgY2FjaGVDb25maWcgPSBjb25maWcuY2FjaGU7XG4gICAgLy8gUmVzcG9uc2UgaXMgYWxyZWFkeSBjYWNoZWRcbiAgICBpZiAocmVzcG9uc2UuY2FjaGVkKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIC8vIFNraXAgY2FjaGU6IGVpdGhlciBmYWxzZSBvciB3ZWlyZCBiZWhhdmlvclxuICAgIC8vIGNvbmZpZy5jYWNoZSBzaG91bGQgYWx3YXlzIGV4aXN0cywgYXQgbGVhc3QgZnJvbSBnbG9iYWwgY29uZmlnIG1lcmdlLlxuICAgIGlmICghY2FjaGVDb25maWcpIHtcbiAgICAgIHJlc3BvbnNlLmNhY2hlZCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICAvLyBVcGRhdGUgb3RoZXIgZW50cmllcyBiZWZvcmUgdXBkYXRpbmcgaGltc2VsZlxuICAgIGlmIChjYWNoZUNvbmZpZy51cGRhdGUpIHtcbiAgICAgIGF3YWl0IHVwZGF0ZUNhY2hlKGF4aW9zLnN0b3JhZ2UsIHJlc3BvbnNlLCBjYWNoZUNvbmZpZy51cGRhdGUpO1xuICAgIH1cbiAgICBpZiAoIWlzTWV0aG9kSW4oY29uZmlnLm1ldGhvZCwgY2FjaGVDb25maWcubWV0aG9kcykpIHtcbiAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgY29uc3QgY2FjaGUgPSBhd2FpdCBheGlvcy5zdG9yYWdlLmdldChyZXNwb25zZS5pZCwgY29uZmlnKTtcbiAgICBpZiAoXG4gICAgLy8gSWYgdGhlIHJlcXVlc3QgaW50ZXJjZXB0b3IgaGFkIGEgcHJvYmxlbSBvciBpdCB3YXNuJ3QgY2FjaGVkXG4gICAgY2FjaGUuc3RhdGUgIT09ICdsb2FkaW5nJykge1xuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICAvLyBDb25maWcgdG9sZCB0aGF0IHRoaXMgcmVzcG9uc2Ugc2hvdWxkIGJlIGNhY2hlZC5cbiAgICBpZiAoXG4gICAgLy8gRm9yICdsb2FkaW5nJyB2YWx1ZXMgKHByZXZpb3VzOiBzdGFsZSksIHRoaXMgY2hlY2sgYWxyZWFkeSByYW4gaW4gdGhlIHBhc3QuXG4gICAgIWNhY2hlLmRhdGEgJiYgIShhd2FpdCB0ZXN0Q2FjaGVQcmVkaWNhdGUocmVzcG9uc2UsIGNhY2hlQ29uZmlnLmNhY2hlUHJlZGljYXRlKSkpIHtcbiAgICAgIGF3YWl0IHJlamVjdFJlc3BvbnNlKHJlc3BvbnNlLmlkLCBjb25maWcsIHRydWUpO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICAvLyBBdm9pZCByZW1uYW50IGhlYWRlcnMgZnJvbSByZW1vdGUgc2VydmVyIHRvIGJyZWFrIGltcGxlbWVudGF0aW9uXG4gICAgZm9yIChjb25zdCBoZWFkZXIgb2YgT2JqZWN0LmtleXMocmVzcG9uc2UuaGVhZGVycykpIHtcbiAgICAgIGlmIChoZWFkZXIuc3RhcnRzV2l0aCgneC1heGlvcy1jYWNoZScpKSB7XG4gICAgICAgIGRlbGV0ZSByZXNwb25zZS5oZWFkZXJzW2hlYWRlcl07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjYWNoZUNvbmZpZy5ldGFnICYmIGNhY2hlQ29uZmlnLmV0YWcgIT09IHRydWUpIHtcbiAgICAgIHJlc3BvbnNlLmhlYWRlcnNbSGVhZGVyLlhBeGlvc0NhY2hlRXRhZ10gPSBjYWNoZUNvbmZpZy5ldGFnO1xuICAgIH1cbiAgICBpZiAoY2FjaGVDb25maWcubW9kaWZpZWRTaW5jZSkge1xuICAgICAgcmVzcG9uc2UuaGVhZGVyc1tIZWFkZXIuWEF4aW9zQ2FjaGVMYXN0TW9kaWZpZWRdID0gY2FjaGVDb25maWcubW9kaWZpZWRTaW5jZSA9PT0gdHJ1ZSA/ICd1c2UtY2FjaGUtdGltZXN0YW1wJyA6IGNhY2hlQ29uZmlnLm1vZGlmaWVkU2luY2UudG9VVENTdHJpbmcoKTtcbiAgICB9XG4gICAgbGV0IHR0bCA9IGNhY2hlQ29uZmlnLnR0bCB8fCAtMTsgLy8gYWx3YXlzIHNldCBmcm9tIGdsb2JhbCBjb25maWdcbiAgICBsZXQgc3RhbGVUdGw7XG4gICAgaWYgKGNhY2hlQ29uZmlnLmludGVycHJldEhlYWRlcikge1xuICAgICAgY29uc3QgZXhwaXJhdGlvblRpbWUgPSBheGlvcy5oZWFkZXJJbnRlcnByZXRlcihyZXNwb25zZS5oZWFkZXJzLCBheGlvcy5sb2NhdGlvbik7XG4gICAgICAvLyBDYWNoZSBzaG91bGQgbm90IGJlIHVzZWRcbiAgICAgIGlmIChleHBpcmF0aW9uVGltZSA9PT0gJ2RvbnQgY2FjaGUnKSB7XG4gICAgICAgIGF3YWl0IHJlamVjdFJlc3BvbnNlKHJlc3BvbnNlLmlkLCBjb25maWcsIHRydWUpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICB9XG4gICAgICBpZiAoZXhwaXJhdGlvblRpbWUgIT09ICdub3QgZW5vdWdoIGhlYWRlcnMnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZXhwaXJhdGlvblRpbWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdHRsID0gZXhwaXJhdGlvblRpbWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHRsID0gZXhwaXJhdGlvblRpbWUuY2FjaGU7XG4gICAgICAgICAgc3RhbGVUdGwgPSBleHBpcmF0aW9uVGltZS5zdGFsZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBkYXRhID0gY3JlYXRlQ2FjaGVSZXNwb25zZShyZXNwb25zZSwgY2FjaGUuZGF0YSk7XG4gICAgaWYgKHR5cGVvZiB0dGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHR0bCA9IGF3YWl0IHR0bChyZXNwb25zZSk7XG4gICAgfVxuICAgIGlmIChjYWNoZUNvbmZpZy5zdGFsZUlmRXJyb3IpIHtcbiAgICAgIHJlc3BvbnNlLmhlYWRlcnNbSGVhZGVyLlhBeGlvc0NhY2hlU3RhbGVJZkVycm9yXSA9IFN0cmluZyh0dGwpO1xuICAgIH1cbiAgICBjb25zdCBuZXdDYWNoZSA9IHtcbiAgICAgIHN0YXRlOiAnY2FjaGVkJyxcbiAgICAgIHR0bCxcbiAgICAgIHN0YWxlVHRsLFxuICAgICAgY3JlYXRlZEF0OiBEYXRlLm5vdygpLFxuICAgICAgZGF0YVxuICAgIH07XG4gICAgLy8gRGVmaW5lIHRoaXMga2V5IGFzIGNhY2hlIG9uIHRoZSBzdG9yYWdlXG4gICAgYXdhaXQgYXhpb3Muc3RvcmFnZS5zZXQocmVzcG9uc2UuaWQsIG5ld0NhY2hlLCBjb25maWcpO1xuICAgIC8vIFJlc29sdmUgYWxsIG90aGVyIHJlcXVlc3RzIHdhaXRpbmcgZm9yIHRoaXMgcmVzcG9uc2VcbiAgICBjb25zdCB3YWl0aW5nID0gYXhpb3Mud2FpdGluZy5nZXQocmVzcG9uc2UuaWQpO1xuICAgIGlmICh3YWl0aW5nKSB7XG4gICAgICB3YWl0aW5nLnJlc29sdmUoKTtcbiAgICAgIGF4aW9zLndhaXRpbmcuZGVsZXRlKHJlc3BvbnNlLmlkKTtcbiAgICB9XG4gICAgLy8gUmV0dXJuIHRoZSByZXNwb25zZSB3aXRoIGNhY2hlZCBhcyBmYWxzZSwgYmVjYXVzZSBpdCB3YXMgbm90IGNhY2hlZCBhdCBhbGxcbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH07XG4gIGNvbnN0IG9uUmVqZWN0ZWQgPSBhc3luYyBlcnJvciA9PiB7XG4gICAgLy8gV2hlbiByZXNwb25zZS5jb25maWcgaXMgbm90IHByZXNlbnQsIHRoZSByZXNwb25zZSBpcyBpbmRlZWQgYSBlcnJvci5cbiAgICBpZiAoIWVycm9yLmlzQXhpb3NFcnJvciB8fCAhZXJyb3IuY29uZmlnKSB7XG4gICAgICAvLyBXZSBzaG91bGQgcHJvYmFibHkgcmUtcmVxdWVzdCB0aGUgcmVzcG9uc2UgdG8gYXZvaWQgYW4gaW5maW5pdGUgbG9hZGluZyBzdGF0ZSBoZXJlXG4gICAgICAvLyBidXQsIHNpbmNlIHRoaXMgaXMgYW4gdW5rbm93biBlcnJvciwgd2UgY2Fubm90IGZpZ3VyZSBvdXQgd2hhdCByZXF1ZXN0IElEIHRvIHVzZS5cbiAgICAgIC8vIEFuZCB0aGUgb25seSBzb2x1dGlvbiBpcyB0byBsZXQgdGhlIHN0b3JhZ2UgYWN0aXZlbHkgcmVqZWN0IHRoZSBjdXJyZW50IGxvYWRpbmcgc3RhdGUuXG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgY29uc3QgY29uZmlnID0gZXJyb3IuY29uZmlnO1xuICAgIGNvbnN0IGlkID0gY29uZmlnLmlkO1xuICAgIGNvbnN0IGNhY2hlQ29uZmlnID0gY29uZmlnLmNhY2hlO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gZXJyb3IucmVzcG9uc2U7XG4gICAgLy8gY29uZmlnLmNhY2hlIHNob3VsZCBhbHdheXMgZXhpc3QsIGF0IGxlYXN0IGZyb20gZ2xvYmFsIGNvbmZpZyBtZXJnZS5cbiAgICBpZiAoIWNhY2hlQ29uZmlnIHx8ICFpZCkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGlmICghaXNNZXRob2RJbihjb25maWcubWV0aG9kLCBjYWNoZUNvbmZpZy5tZXRob2RzKSkge1xuICAgICAgLy8gUmVqZWN0cyBhbGwgb3RoZXIgcmVxdWVzdHMgd2FpdGluZyBmb3IgdGhpcyByZXNwb25zZVxuICAgICAgYXdhaXQgcmVqZWN0UmVzcG9uc2UoaWQsIGNvbmZpZywgdHJ1ZSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgY29uc3QgY2FjaGUgPSBhd2FpdCBheGlvcy5zdG9yYWdlLmdldChpZCwgY29uZmlnKTtcbiAgICBpZiAoXG4gICAgLy8gVGhpcyB3aWxsIG9ubHkgbm90IGJlIGxvYWRpbmcgaWYgdGhlIGludGVyY2VwdG9yIGJyb2tlXG4gICAgY2FjaGUuc3RhdGUgIT09ICdsb2FkaW5nJyB8fCBjYWNoZS5wcmV2aW91cyAhPT0gJ3N0YWxlJykge1xuICAgICAgLy8gUmVqZWN0cyBhbGwgb3RoZXIgcmVxdWVzdHMgd2FpdGluZyBmb3IgdGhpcyByZXNwb25zZVxuICAgICAgYXdhaXQgcmVqZWN0UmVzcG9uc2UoaWQsIGNvbmZpZyxcbiAgICAgIC8vIERvIG5vdCBjbGVhciBjYWNoZSBpZiB0aGlzIHJlcXVlc3QgaXMgY2FjaGVkLCBidXQgdGhlIHJlcXVlc3Qgd2FzIGNhbmNlbGxlZCBiZWZvcmUgcmV0dXJuaW5nIHRoZSBjYWNoZWQgcmVzcG9uc2VcbiAgICAgIGVycm9yLmNvZGUgIT09ICdFUlJfQ0FOQ0VMRUQnIHx8IGVycm9yLmNvZGUgPT09ICdFUlJfQ0FOQ0VMRUQnICYmIGNhY2hlLnN0YXRlICE9PSAnY2FjaGVkJyk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgaWYgKGNhY2hlQ29uZmlnLnN0YWxlSWZFcnJvcikge1xuICAgICAgY29uc3QgY2FjaGVDb250cm9sID0gU3RyaW5nKHJlc3BvbnNlID09IG51bGwgPyB2b2lkIDAgOiByZXNwb25zZS5oZWFkZXJzW0hlYWRlci5DYWNoZUNvbnRyb2xdKTtcbiAgICAgIGNvbnN0IHN0YWxlSGVhZGVyID0gY2FjaGVDb250cm9sICYmIHBhcnNlKGNhY2hlQ29udHJvbCkuc3RhbGVJZkVycm9yO1xuICAgICAgY29uc3Qgc3RhbGVJZkVycm9yID0gdHlwZW9mIGNhY2hlQ29uZmlnLnN0YWxlSWZFcnJvciA9PT0gJ2Z1bmN0aW9uJyA/IGF3YWl0IGNhY2hlQ29uZmlnLnN0YWxlSWZFcnJvcihyZXNwb25zZSwgY2FjaGUsIGVycm9yKSA6IGNhY2hlQ29uZmlnLnN0YWxlSWZFcnJvciA9PT0gdHJ1ZSAmJiBzdGFsZUhlYWRlciA/IHN0YWxlSGVhZGVyICogMTAwMCAvL3N0YWxlSWZFcnJvciBpcyBpbiBzZWNvbmRzXG4gICAgICA6IGNhY2hlQ29uZmlnLnN0YWxlSWZFcnJvcjtcbiAgICAgIGlmIChzdGFsZUlmRXJyb3IgPT09IHRydWUgfHxcbiAgICAgIC8vIHN0YWxlSWZFcnJvciBpcyB0aGUgbnVtYmVyIG9mIHNlY29uZHMgdGhhdCBzdGFsZSBpcyBhbGxvd2VkIHRvIGJlIHVzZWRcbiAgICAgIHR5cGVvZiBzdGFsZUlmRXJyb3IgPT09ICdudW1iZXInICYmIGNhY2hlLmNyZWF0ZWRBdCArIHN0YWxlSWZFcnJvciA+IERhdGUubm93KCkpIHtcbiAgICAgICAgLy8gcmUtbWFyayB0aGUgY2FjaGUgYXMgc3RhbGVcbiAgICAgICAgYXdhaXQgYXhpb3Muc3RvcmFnZS5zZXQoaWQsIHtcbiAgICAgICAgICBzdGF0ZTogJ3N0YWxlJyxcbiAgICAgICAgICBjcmVhdGVkQXQ6IERhdGUubm93KCksXG4gICAgICAgICAgZGF0YTogY2FjaGUuZGF0YVxuICAgICAgICB9LCBjb25maWcpO1xuICAgICAgICAvLyBSZXNvbHZlIGFsbCBvdGhlciByZXF1ZXN0cyB3YWl0aW5nIGZvciB0aGlzIHJlc3BvbnNlXG4gICAgICAgIGNvbnN0IHdhaXRpbmcgPSBheGlvcy53YWl0aW5nLmdldChpZCk7XG4gICAgICAgIGlmICh3YWl0aW5nKSB7XG4gICAgICAgICAgd2FpdGluZy5yZXNvbHZlKCk7XG4gICAgICAgICAgYXhpb3Mud2FpdGluZy5kZWxldGUoaWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2FjaGVkOiB0cnVlLFxuICAgICAgICAgIHN0YWxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBkYXRhOiBjYWNoZS5kYXRhLmRhdGEsXG4gICAgICAgICAgaGVhZGVyczogY2FjaGUuZGF0YS5oZWFkZXJzLFxuICAgICAgICAgIHN0YXR1czogY2FjaGUuZGF0YS5zdGF0dXMsXG4gICAgICAgICAgc3RhdHVzVGV4dDogY2FjaGUuZGF0YS5zdGF0dXNUZXh0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFJlamVjdHMgYWxsIG90aGVyIHJlcXVlc3RzIHdhaXRpbmcgZm9yIHRoaXMgcmVzcG9uc2VcbiAgICBhd2FpdCByZWplY3RSZXNwb25zZShpZCwgY29uZmlnLCB0cnVlKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBvbkZ1bGZpbGxlZCxcbiAgICBvblJlamVjdGVkXG4gIH07XG59XG5cbi8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIHByb3ZpZGVkIG9iamVjdCB3YXMgY3JlYXRlZCBmcm9tIHtAbGluayBidWlsZFN0b3JhZ2V9IGZ1bmN0aW9uLiAqL1xuY29uc3QgaXNTdG9yYWdlID0gb2JqID0+ICEhb2JqICYmICEhb2JqWydpcy1zdG9yYWdlJ107XG5mdW5jdGlvbiBoYXNVbmlxdWVJZGVudGlmaWVySGVhZGVyKHZhbHVlKSB7XG4gIGNvbnN0IGhlYWRlcnMgPSB2YWx1ZS5kYXRhLmhlYWRlcnM7XG4gIHJldHVybiBIZWFkZXIuRVRhZyBpbiBoZWFkZXJzIHx8IEhlYWRlci5MYXN0TW9kaWZpZWQgaW4gaGVhZGVycyB8fCBIZWFkZXIuWEF4aW9zQ2FjaGVFdGFnIGluIGhlYWRlcnMgfHwgSGVhZGVyLlhBeGlvc0NhY2hlTGFzdE1vZGlmaWVkIGluIGhlYWRlcnM7XG59XG4vKiogUmV0dXJucyB0cnVlIGlmIHZhbHVlIG11c3QgYmUgcmV2YWxpZGF0ZWQgKi9cbmZ1bmN0aW9uIG11c3RSZXZhbGlkYXRlKHZhbHVlKSB7XG4gIC8vIE11c3QgcmV2YWxpZGF0ZSBpcyBhIHNwZWNpYWwgY2FzZSBhbmQgc2hvdWxkIG5vdCBzZXJ2ZSBzdGFsZSB2YWx1ZXNcbiAgLy8gV2UgY291bGQgdXNlIGNhY2hlLWNvbnRyb2wncyBwYXJzZSBmdW5jdGlvbiwgYnV0IHRoaXMgaXMgd2F5IGZhc3RlciBhbmQgc2ltcGxlclxuICByZXR1cm4gU3RyaW5nKHZhbHVlLmRhdGEuaGVhZGVyc1tIZWFkZXIuQ2FjaGVDb250cm9sXSkuaW5jbHVkZXMoJ211c3QtcmV2YWxpZGF0ZScpO1xufVxuLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGhhcyBzdWZmaWNpZW50IHByb3BlcnRpZXMgdG8gc3RhbGUgaW5zdGVhZCBvZiBleHBpcmUuICovXG5mdW5jdGlvbiBjYW5TdGFsZSh2YWx1ZSkge1xuICBpZiAoaGFzVW5pcXVlSWRlbnRpZmllckhlYWRlcih2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gdmFsdWUuc3RhdGUgPT09ICdjYWNoZWQnICYmIHZhbHVlLnN0YWxlVHRsICE9PSB1bmRlZmluZWQgJiZcbiAgLy8gT25seSBhbGxvdyBzdGFsZSB2YWx1ZXMgYWZ0ZXIgdGhlIHR0bCBpcyBhbHJlYWR5IGluIHRoZSBwYXN0IGFuZCB0aGUgc3RhbGVUdGwgaXMgaW4gdGhlIGZ1dHVyZS5cbiAgLy8gSW4gY2FzZXMgdGhhdCBqdXN0IGNyZWF0ZWRBdCArIHR0bCA+IERhdGUubm93KCksIGlzbid0IGVub3VnaCBiZWNhdXNlIHRoZSBzdGFsZVR0bCBjb3VsZCBiZSA8PSAwLlxuICAvLyBUaGlzIGxvZ2ljIG9ubHkgcmV0dXJucyB0cnVlIHdoZW4gRGF0ZS5ub3coKSBpcyBiZXR3ZWVuIHRoZSAoY3JlYXRlZEF0ICsgdHRsKSBhbmQgKGNyZWF0ZWRBdCArIHR0bCArIHN0YWxlVHRsKS5cbiAgLy8gRm9sbG93aW5nIHRoZSBleGFtcGxlIGJlbG93OlxuICAvLyB8LS1jcmVhdGVkQXQtLTotLXR0bC0tOi0tLXN0YWxlVHRsLS0tPlxuICAvLyBbICAgICAgICBwYXN0ICAgICAgICBdW25vdyBpcyBpbiBoZXJlXVxuICBNYXRoLmFicyhEYXRlLm5vdygpIC0gKHZhbHVlLmNyZWF0ZWRBdCArIHZhbHVlLnR0bCkpIDw9IHZhbHVlLnN0YWxlVHRsO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHByb3ZpZGVkIGNhY2hlIGlzIGV4cGlyZWQuIFlvdSBzaG91bGQgYWxzbyBjaGVjayBpZiB0aGUgY2FjaGVcbiAqIHtAbGluayBjYW5TdGFsZX0gYW5kIHtAbGluayBtYXlVc2VTdGFsZX1cbiAqL1xuZnVuY3Rpb24gaXNFeHBpcmVkKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS50dGwgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZS5jcmVhdGVkQXQgKyB2YWx1ZS50dGwgPD0gRGF0ZS5ub3coKTtcbn1cbi8qKlxuICogQWxsIGludGVncmF0ZWQgc3RvcmFnZXMgYXJlIHdyYXBwZXJzIGFyb3VuZCB0aGUgYGJ1aWxkU3RvcmFnZWAgZnVuY3Rpb24uIEV4dGVybmFsXG4gKiBsaWJyYXJpZXMgdXNlIGl0IGFuZCBpZiB5b3Ugd2FudCB0byBidWlsZCB5b3VyIG93biwgYGJ1aWxkU3RvcmFnZWAgaXMgdGhlIHdheSB0byBnbyFcbiAqXG4gKiBUaGUgZXhwb3J0ZWQgYGJ1aWxkU3RvcmFnZWAgZnVuY3Rpb24gYWJzdHJhY3RzIHRoZSBzdG9yYWdlIGludGVyZmFjZSBhbmQgcmVxdWlyZXMgYVxuICogc3VwZXIgc2ltcGxlIG9iamVjdCB0byBidWlsZCB0aGUgc3RvcmFnZS5cbiAqXG4gKiAqKk5vdGUqKjogWW91IGNhbiBvbmx5IGNyZWF0ZSBhbiBjdXN0b20gc3RvcmFnZSB3aXRoIHRoaXMgZnVuY3Rpb24uXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogY29uc3QgbXlTdG9yYWdlID0gYnVpbGRTdG9yYWdlKHtcbiAqICAgZmluZDogKCkgPT4gey4uLn0sXG4gKiAgIHNldDogKCkgPT4gey4uLn0sXG4gKiAgIHJlbW92ZTogKCkgPT4gey4uLn0sXG4gKiAgIGNsZWFyOiAoKSA9PiB7Li4ufVxuICogfSk7XG4gKlxuICogY29uc3QgYXhpb3MgPSBzZXR1cENhY2hlKGF4aW9zLCB7IHN0b3JhZ2U6IG15U3RvcmFnZSB9KTtcbiAqIGBgYFxuICpcbiAqIEBzZWUgaHR0cHM6Ly9heGlvcy1jYWNoZS1pbnRlcmNlcHRvci5qcy5vcmcvZ3VpZGUvc3RvcmFnZXMjYnVpbGRzdG9yYWdlXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkU3RvcmFnZSh7XG4gIHNldCxcbiAgZmluZCxcbiAgcmVtb3ZlLFxuICBjbGVhclxufSkge1xuICByZXR1cm4ge1xuICAgIC8vQHRzLWV4cGVjdC1lcnJvciAtIHdlIGRvbid0IHdhbnQgdG8gZXhwb3NlIHRoaXNcbiAgICAnaXMtc3RvcmFnZSc6IDEsXG4gICAgc2V0LFxuICAgIHJlbW92ZSxcbiAgICBjbGVhcixcbiAgICBnZXQ6IGFzeW5jIChrZXksIGNvbmZpZykgPT4ge1xuICAgICAgbGV0IHZhbHVlID0gYXdhaXQgZmluZChrZXksIGNvbmZpZyk7XG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RhdGU6ICdlbXB0eSdcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZS5zdGF0ZSA9PT0gJ2VtcHR5JyB8fCB2YWx1ZS5zdGF0ZSA9PT0gJ2xvYWRpbmcnIHx8IHZhbHVlLnN0YXRlID09PSAnbXVzdC1yZXZhbGlkYXRlJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICAvLyBIYW5kbGUgY2FjaGVkIHZhbHVlc1xuICAgICAgaWYgKHZhbHVlLnN0YXRlID09PSAnY2FjaGVkJykge1xuICAgICAgICBpZiAoIWlzRXhwaXJlZCh2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHJpZXMgdG8gc3RhbGUgZXhwaXJlZCB2YWx1ZVxuICAgICAgICBpZiAoIWNhblN0YWxlKHZhbHVlKSkge1xuICAgICAgICAgIGF3YWl0IHJlbW92ZShrZXksIGNvbmZpZyk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXRlOiAnZW1wdHknXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IHtcbiAgICAgICAgICBzdGF0ZTogJ3N0YWxlJyxcbiAgICAgICAgICBjcmVhdGVkQXQ6IHZhbHVlLmNyZWF0ZWRBdCxcbiAgICAgICAgICBkYXRhOiB2YWx1ZS5kYXRhLFxuICAgICAgICAgIHR0bDogdmFsdWUuc3RhbGVUdGwgIT09IHVuZGVmaW5lZCA/IHZhbHVlLnN0YWxlVHRsICsgdmFsdWUudHRsIDogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgICAgIGF3YWl0IHNldChrZXksIHZhbHVlLCBjb25maWcpO1xuICAgICAgICAvLyBNdXN0IHJldmFsaWRhdGUgaXMgYSBzcGVjaWFsIGNhc2UgYW5kIHNob3VsZCBub3Qgc2VydmUgc3RhbGUgdmFsdWVzXG4gICAgICAgIGlmIChtdXN0UmV2YWxpZGF0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHZhbHVlLCB7XG4gICAgICAgICAgICBzdGF0ZTogJ211c3QtcmV2YWxpZGF0ZSdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQSBzZWNvbmQgY2hlY2sgaW4gY2FzZSB0aGUgbmV3IHN0YWxlIHZhbHVlIHdhcyBjcmVhdGVkIGFscmVhZHkgZXhwaXJlZC5cbiAgICAgIGlmICghaXNFeHBpcmVkKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoaGFzVW5pcXVlSWRlbnRpZmllckhlYWRlcih2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgYXdhaXQgcmVtb3ZlKGtleSwgY29uZmlnKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXRlOiAnZW1wdHknXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cblxuLyogYzggaWdub3JlIHN0YXJ0ICovXG4vKipcbiAqIENsb25lcyBhbiBvYmplY3QgdXNpbmcgdGhlIHN0cnVjdHVyZWQgY2xvbmUgYWxnb3JpdGhtIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlXG4gKiBpdCB1c2VzIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodmFsdWUpKS5cbiAqL1xuY29uc3QgY2xvbmUgPVxuLy8gaHR0cHM6Ly9jYW5pdXNlLmNvbS9tZG4tYXBpX3N0cnVjdHVyZWRjbG9uZSAoMTAvMTgvMjAyMyA5Mi41MSUpXG50eXBlb2Ygc3RydWN0dXJlZENsb25lID09PSAnZnVuY3Rpb24nID8gc3RydWN0dXJlZENsb25lIDogdmFsdWUgPT4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuLyogYzggaWdub3JlIHN0b3AgKi9cbi8qKlxuICogQ3JlYXRlcyBhIHNpbXBsZSBpbi1tZW1vcnkgc3RvcmFnZS4gVGhpcyBtZWFucyB0aGF0IGlmIHlvdSBuZWVkIHRvIHBlcnNpc3QgZGF0YSBiZXR3ZWVuXG4gKiBwYWdlIG9yIHNlcnZlciByZWxvYWRzLCB0aGlzIHdpbGwgbm90IGhlbHAuXG4gKlxuICogVGhpcyBpcyB0aGUgc3RvcmFnZSB1c2VkIGJ5IGRlZmF1bHQuXG4gKlxuICogSWYgeW91IG5lZWQgdG8gbW9kaWZ5IGl0J3MgZGF0YSwgeW91IGNhbiBkbyBieSB0aGUgYGRhdGFgIHByb3BlcnR5LlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIGNvbnN0IG1lbW9yeVN0b3JhZ2UgPSBidWlsZE1lbW9yeVN0b3JhZ2UoKTtcbiAqXG4gKiBzZXR1cENhY2hlKGF4aW9zLCB7IHN0b3JhZ2U6IG1lbW9yeVN0b3JhZ2UgfSk7XG4gKlxuICogLy8gU2ltcGxlIGV4YW1wbGUgdG8gZm9yY2UgZGVsZXRlIHRoZSByZXF1ZXN0IGNhY2hlXG4gKlxuICogY29uc3QgeyBpZCB9ID0gYXhpb3MuZ2V0KCd1cmwnKTtcbiAqXG4gKiBkZWxldGUgbWVtb3J5U3RvcmFnZS5kYXRhW2lkXTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbiB8ICdkb3VibGUnfSBjbG9uZURhdGEgVXNlIGB0cnVlYCBpZiB0aGUgZGF0YSByZXR1cm5lZCBieSBgZmluZCgpYFxuICogICBzaG91bGQgYmUgY2xvbmVkIHRvIGF2b2lkIG11dGF0aW5nIHRoZSBvcmlnaW5hbCBkYXRhIG91dHNpZGUgdGhlIGBzZXQoKWAgbWV0aG9kLiBVc2VcbiAqICAgYCdkb3VibGUnYCB0byBhbHNvIGNsb25lIGJlZm9yZSBzYXZpbmcgdmFsdWUgaW4gc3RvcmFnZSB1c2luZyBgc2V0KClgLiBEaXNhYmxlZCBpc1xuICogICBkZWZhdWx0XG4gKiBAcGFyYW0ge251bWJlciB8IGZhbHNlfSBjbGVhbnVwSW50ZXJ2YWwgVGhlIGludGVydmFsIGluIG1pbGxpc2Vjb25kcyB0byBydW4gYVxuICogICBzZXRJbnRlcnZhbCBqb2Igb2YgY2xlYW5pbmcgb2xkIGVudHJpZXMuIElmIGZhbHNlLCB0aGUgam9iIHdpbGwgbm90IGJlIGNyZWF0ZWQuXG4gKiAgIERpc2FibGVkIGlzIGRlZmF1bHRcbiAqIEBwYXJhbSB7bnVtYmVyIHwgZmFsc2V9IG1heEVudHJpZXMgVGhlIG1heGltdW0gbnVtYmVyIG9mIGVudHJpZXMgdG8ga2VlcCBpbiB0aGVcbiAqICAgc3RvcmFnZS4gSXRzIGhhcmQgdG8gZGV0ZXJtaW5lIHRoZSBzaXplIG9mIHRoZSBlbnRyaWVzLCBzbyBhIHNtYXJ0IEZJRk8gb3JkZXIgaXMgdXNlZFxuICogICB0byBkZXRlcm1pbmUgZXZpY3Rpb24uIElmIGZhbHNlLCBubyBjaGVjayB3aWxsIGJlIGRvbmUgYW5kIHlvdSBtYXkgZ3JvdyB1cCBtZW1vcnlcbiAqICAgdXNhZ2UuIERpc2FibGVkIGlzIGRlZmF1bHRcbiAqL1xuZnVuY3Rpb24gYnVpbGRNZW1vcnlTdG9yYWdlKGNsb25lRGF0YSA9IGZhbHNlLCBjbGVhbnVwSW50ZXJ2YWwgPSBmYWxzZSwgbWF4RW50cmllcyA9IGZhbHNlKSB7XG4gIGNvbnN0IHN0b3JhZ2UgPSBidWlsZFN0b3JhZ2Uoe1xuICAgIHNldDogKGtleSwgdmFsdWUpID0+IHtcbiAgICAgIGlmIChtYXhFbnRyaWVzKSB7XG4gICAgICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXMoc3RvcmFnZS5kYXRhKTtcbiAgICAgICAgLy8gVHJpZXMgdG8gY2xlYW51cCBmaXJzdFxuICAgICAgICBpZiAoa2V5cy5sZW5ndGggPj0gbWF4RW50cmllcykge1xuICAgICAgICAgIHN0b3JhZ2UuY2xlYW51cCgpO1xuICAgICAgICAgIC8vIFJlY2FsY3VsYXRlcyB0aGUga2V5c1xuICAgICAgICAgIGtleXMgPSBPYmplY3Qua2V5cyhzdG9yYWdlLmRhdGEpO1xuICAgICAgICAgIC8vIEtlZXBzIGRlbGV0aW5nIHVudGlsIHRoZXJlJ3Mgc3BhY2VcbiAgICAgICAgICB3aGlsZSAoa2V5cy5sZW5ndGggPj0gbWF4RW50cmllcykge1xuICAgICAgICAgICAgLy8gVGhlcmUncyBhbHdheXMgYXQgbGVhc3Qgb25lIGtleSBoZXJlLCBvdGhlcndpc2UgaXQgd291bGQgbm90IGJlXG4gICAgICAgICAgICAvLyBpbiB0aGUgbG9vcC5cbiAgICAgICAgICAgIGRlbGV0ZSBzdG9yYWdlLmRhdGFba2V5cy5zaGlmdCgpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIENsb25lIHRoZSB2YWx1ZSBiZWZvcmUgc3RvcmluZyB0byBwcmV2ZW50IGZ1dHVyZSBtdXRhdGlvbnNcbiAgICAgIC8vIGZyb20gYWZmZWN0aW5nIGNhY2hlZCBkYXRhLlxuICAgICAgc3RvcmFnZS5kYXRhW2tleV0gPSBjbG9uZURhdGEgPT09ICdkb3VibGUnID8gY2xvbmUodmFsdWUpIDogdmFsdWU7XG4gICAgfSxcbiAgICByZW1vdmU6IGtleSA9PiB7XG4gICAgICBkZWxldGUgc3RvcmFnZS5kYXRhW2tleV07XG4gICAgfSxcbiAgICBmaW5kOiBrZXkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSBzdG9yYWdlLmRhdGFba2V5XTtcbiAgICAgIHJldHVybiBjbG9uZURhdGEgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCA/IGNsb25lKHZhbHVlKSA6IHZhbHVlO1xuICAgIH0sXG4gICAgY2xlYXI6ICgpID0+IHtcbiAgICAgIHN0b3JhZ2UuZGF0YSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICB9KTtcbiAgc3RvcmFnZS5kYXRhID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgLy8gV2hlbiB0aGlzIHByb2dyYW0gZ2V0cyBydW5uaW5nIGZvciBtb3JlIHRoYW4gdGhlIHNwZWNpZmllZCBpbnRlcnZhbCwgdGhlcmUncyBhIGdvb2RcbiAgLy8gY2hhbmNlIG9mIGl0IGJlaW5nIGEgbG9uZy1ydW5uaW5nIHByb2Nlc3Mgb3IgYXQgbGVhc3QgaGF2ZSBhIGxvdCBvZiBlbnRyaWVzLiBUaGVyZWZvcmUsXG4gIC8vIFwiZmFzdGVyXCIgbG9vcCBpcyBtb3JlIGltcG9ydGFudCB0aGFuIGNvZGUgcmVhZGFiaWxpdHkuXG4gIHN0b3JhZ2UuY2xlYW51cCA9ICgpID0+IHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoc3RvcmFnZS5kYXRhKTtcbiAgICBsZXQgaSA9IC0xO1xuICAgIGxldCB2YWx1ZTtcbiAgICBsZXQga2V5O1xuICAgIC8vIExvb3BpbmcgZm9yd2FyZCwgYXMgb2xkZXIgZW50cmllcyBhcmUgbW9yZSBsaWtlbHkgdG8gYmUgZXhwaXJlZFxuICAgIC8vIHRoYW4gbmV3ZXIgb25lcy5cbiAgICB3aGlsZSAoKytpIDwga2V5cy5sZW5ndGgpIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICB2YWx1ZSA9IHN0b3JhZ2UuZGF0YVtrZXldO1xuICAgICAgaWYgKHZhbHVlLnN0YXRlID09PSAnZW1wdHknKSB7XG4gICAgICAgIHN0b3JhZ2UucmVtb3ZlKGtleSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLy8gSWYgdGhlIHZhbHVlIGlzIGV4cGlyZWQgYW5kIGNhbid0IGJlIHN0YWxlLCByZW1vdmUgaXRcbiAgICAgIGlmICh2YWx1ZS5zdGF0ZSA9PT0gJ2NhY2hlZCcgJiYgaXNFeHBpcmVkKHZhbHVlKSAmJiAhY2FuU3RhbGUodmFsdWUpKSB7XG4gICAgICAgIC8vIHRoaXMgc3RvcmFnZSByZXR1cm5zIHZvaWQuXG4gICAgICAgIHN0b3JhZ2UucmVtb3ZlKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBpZiAoY2xlYW51cEludGVydmFsKSB7XG4gICAgc3RvcmFnZS5jbGVhbmVyID0gc2V0SW50ZXJ2YWwoc3RvcmFnZS5jbGVhbnVwLCBjbGVhbnVwSW50ZXJ2YWwpO1xuICB9XG4gIHJldHVybiBzdG9yYWdlO1xufVxuXG4vLyBSZW1vdmUgZmlyc3QgYW5kIGxhc3QgJy8nIGNoYXIsIGlmIHByZXNlbnRcbmNvbnN0IFNMQVNIRVNfUkVHRVggPSAvXlxcL3xcXC8kL2c7XG4vKipcbiAqIEJ1aWxkcyBhbiBnZW5lcmF0b3IgdGhhdCByZWNlaXZlcyBhIHtAbGluayBDYWNoZVJlcXVlc3RDb25maWd9IGFuZCByZXR1cm5zIGEgdmFsdWVcbiAqIGhhc2hlZCBieSB7QGxpbmsgaGFzaH0uXG4gKlxuICogVGhlIHZhbHVlIGlzIGhhc2hlZCBpbnRvIGEgc2lnbmVkIGludGVnZXIgd2hlbiB0aGUgcmV0dXJuZWQgdmFsdWUgZnJvbSB0aGUgcHJvdmlkZWRcbiAqIGdlbmVyYXRvciBpcyBub3QgYSBgc3RyaW5nYCBvciBhIGBudW1iZXJgLlxuICpcbiAqIFlvdSBjYW4gcmV0dXJuIGFueSB0eXBlIG9mIGRhdGEgc3RydWN0dXJlLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIC8vIFRoaXMgZ2VuZXJhdG9yIHdpbGwgcmV0dXJuIGEgaGFzaCBjb2RlLlxuICogLy8gVGhlIGNvZGUgd2lsbCBvbmx5IGJlIHRoZSBzYW1lIGlmIHVybCwgbWV0aG9kIGFuZCBkYXRhIGFyZSB0aGUgc2FtZS5cbiAqIGNvbnN0IGdlbmVyYXRvciA9IGJ1aWxkS2V5R2VuZXJhdG9yKCh7IHVybCwgbWV0aG9kLCBkYXRhIH0pID0+ICh7XG4gKiAgIHVybCxcbiAqICAgbWV0aG9kLFxuICogICBkYXRhXG4gKiB9KSk7XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gYnVpbGRLZXlHZW5lcmF0b3IoZ2VuZXJhdG9yKSB7XG4gIHJldHVybiByZXF1ZXN0ID0+IHtcbiAgICBpZiAocmVxdWVzdC5pZCkge1xuICAgICAgcmV0dXJuIHJlcXVlc3QuaWQ7XG4gICAgfVxuICAgIGNvbnN0IGtleSA9IGdlbmVyYXRvcihyZXF1ZXN0KTtcbiAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGtleSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiBgJHtrZXl9YDtcbiAgICB9XG4gICAgcmV0dXJuIGAke2hhc2goa2V5KX1gO1xuICB9O1xufVxuY29uc3QgZGVmYXVsdEtleUdlbmVyYXRvciA9IGJ1aWxkS2V5R2VuZXJhdG9yKCh7XG4gIGJhc2VVUkwsXG4gIHVybCxcbiAgbWV0aG9kLFxuICBwYXJhbXMsXG4gIGRhdGFcbn0pID0+IHtcbiAgLy8gUmVtb3ZlIHRyYWlsaW5nIHNsYXNoZXMgdG8gYXZvaWQgZ2VuZXJhdGluZyBkaWZmZXJlbnQga2V5cyBmb3IgdGhlIFwic2FtZVwiIGZpbmFsIHVybC5cbiAgaWYgKGJhc2VVUkwgIT09IHVuZGVmaW5lZCkge1xuICAgIGJhc2VVUkwgPSBiYXNlVVJMLnJlcGxhY2UoU0xBU0hFU19SRUdFWCwgJycpO1xuICB9IGVsc2Uge1xuICAgIC8vIGp1c3QgdG8gaGF2ZSBhIGNvbnNpc3RlbnQgaGFzaFxuICAgIGJhc2VVUkwgPSAnJztcbiAgfVxuICBpZiAodXJsICE9PSB1bmRlZmluZWQpIHtcbiAgICB1cmwgPSB1cmwucmVwbGFjZShTTEFTSEVTX1JFR0VYLCAnJyk7XG4gIH0gZWxzZSB7XG4gICAgLy8ganVzdCB0byBoYXZlIGEgY29uc2lzdGVudCBoYXNoXG4gICAgdXJsID0gJyc7XG4gIH1cbiAgaWYgKG1ldGhvZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbWV0aG9kID0gbWV0aG9kLnRvTG93ZXJDYXNlKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8ganVzdCB0byBoYXZlIGEgY29uc2lzdGVudCBoYXNoXG4gICAgbWV0aG9kID0gJ2dldCc7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB1cmw6IGJhc2VVUkwgKyAoYmFzZVVSTCAmJiB1cmwgPyAnLycgOiAnJykgKyB1cmwsXG4gICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgbWV0aG9kOiBtZXRob2QsXG4gICAgZGF0YTogZGF0YVxuICB9O1xufSk7XG5cbi8qKlxuICogQXBwbHkgdGhlIGNhY2hpbmcgaW50ZXJjZXB0b3JzIGZvciBhIGFscmVhZHkgY3JlYXRlZCBheGlvcyBpbnN0YW5jZS5cbiAqXG4gKiBgYGB0c1xuICogY29uc3QgYXhpb3MgPSBzZXR1cENhY2hlKGF4aW9zLCBPUFRJT05TKTtcbiAqIGBgYFxuICpcbiAqIFRoZSBgc2V0dXBDYWNoZWAgZnVuY3Rpb24gcmVjZWl2ZXMgZ2xvYmFsIG9wdGlvbnMgYW5kIGFsbCBbcmVxdWVzdFxuICogc3BlY2lmaWNzXShodHRwczovL2F4aW9zLWNhY2hlLWludGVyY2VwdG9yLmpzLm9yZy9jb25maWcvcmVxdWVzdC1zcGVjaWZpY3MpIG9uZXMgdG9vLlxuICogVGhpcyB3YXksIHlvdSBjYW4gY3VzdG9taXplIHRoZSBkZWZhdWx0cyBmb3IgYWxsIHJlcXVlc3RzLlxuICpcbiAqIEBwYXJhbSBheGlvcyBUaGUgYWxyZWFkeSBjcmVhdGVkIGF4aW9zIGluc3RhbmNlXG4gKiBAcGFyYW0gY29uZmlnIFRoZSBjb25maWcgZm9yIHRoZSBjYWNoaW5nIGludGVyY2VwdG9yc1xuICogQHJldHVybnMgVGhlIHNhbWUgaW5zdGFuY2Ugd2l0aCBleHRlbmRlZCB0eXBlc2NyaXB0IHR5cGVzLlxuICogQHNlZSBodHRwczovL2F4aW9zLWNhY2hlLWludGVyY2VwdG9yLmpzLm9yZy9jb25maWdcbiAqL1xuZnVuY3Rpb24gc2V0dXBDYWNoZShheGlvcywgb3B0aW9ucyA9IHt9KSB7XG4gIHZhciBfb3B0aW9ucyR0dGwsIF9vcHRpb25zJGV0YWcsIF9vcHRpb25zJG1vZGlmaWVkU2luYywgX29wdGlvbnMkaW50ZXJwcmV0SGVhLCBfb3B0aW9ucyRjYWNoZVRha2VvdmUsIF9vcHRpb25zJHN0YWxlSWZFcnJvciwgX29wdGlvbnMkb3ZlcnJpZGUsIF9vcHRpb25zJGh5ZHJhdGU7XG4gIGNvbnN0IGF4aW9zQ2FjaGUgPSBheGlvcztcbiAgaWYgKGF4aW9zQ2FjaGUuZGVmYXVsdHMuY2FjaGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldHVwQ2FjaGUoKSBzaG91bGQgYmUgY2FsbGVkIG9ubHkgb25jZScpO1xuICB9XG4gIGF4aW9zQ2FjaGUubG9jYXRpb24gPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/ICdzZXJ2ZXInIDogJ2NsaWVudCc7XG4gIGF4aW9zQ2FjaGUuc3RvcmFnZSA9IG9wdGlvbnMuc3RvcmFnZSB8fCBidWlsZE1lbW9yeVN0b3JhZ2UoKTtcbiAgaWYgKCFpc1N0b3JhZ2UoYXhpb3NDYWNoZS5zdG9yYWdlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVXNlIGJ1aWxkU3RvcmFnZSgpIGZ1bmN0aW9uJyk7XG4gIH1cbiAgYXhpb3NDYWNoZS53YWl0aW5nID0gb3B0aW9ucy53YWl0aW5nIHx8IG5ldyBNYXAoKTtcbiAgYXhpb3NDYWNoZS5nZW5lcmF0ZUtleSA9IG9wdGlvbnMuZ2VuZXJhdGVLZXkgfHwgZGVmYXVsdEtleUdlbmVyYXRvcjtcbiAgYXhpb3NDYWNoZS5oZWFkZXJJbnRlcnByZXRlciA9IG9wdGlvbnMuaGVhZGVySW50ZXJwcmV0ZXIgfHwgZGVmYXVsdEhlYWRlckludGVycHJldGVyO1xuICBheGlvc0NhY2hlLnJlcXVlc3RJbnRlcmNlcHRvciA9IG9wdGlvbnMucmVxdWVzdEludGVyY2VwdG9yIHx8IGRlZmF1bHRSZXF1ZXN0SW50ZXJjZXB0b3IoYXhpb3NDYWNoZSk7XG4gIGF4aW9zQ2FjaGUucmVzcG9uc2VJbnRlcmNlcHRvciA9IG9wdGlvbnMucmVzcG9uc2VJbnRlcmNlcHRvciB8fCBkZWZhdWx0UmVzcG9uc2VJbnRlcmNlcHRvcihheGlvc0NhY2hlKTtcbiAgYXhpb3NDYWNoZS5kZWJ1ZyA9IG9wdGlvbnMuZGVidWcgfHwgZnVuY3Rpb24gbm9vcCgpIHt9O1xuICAvLyBDYWNoZVJlcXVlc3RDb25maWcgdmFsdWVzXG4gIGF4aW9zQ2FjaGUuZGVmYXVsdHMuY2FjaGUgPSB7XG4gICAgdXBkYXRlOiBvcHRpb25zLnVwZGF0ZSB8fCB7fSxcbiAgICB0dGw6IChfb3B0aW9ucyR0dGwgPSBvcHRpb25zLnR0bCkgIT0gbnVsbCA/IF9vcHRpb25zJHR0bCA6IDEwMDAgKiA2MCAqIDUsXG4gICAgLy8gQWx0aG91Z2ggUkZDIDcyMzEgYWxzbyBtYXJrcyBQT1NUIGFzIGNhY2hlYWJsZSwgbW9zdCB1c2VycyBkb24ndCBrbm93IHRoYXRcbiAgICAvLyBhbmQgbWF5IGhhdmUgcHJvYmxlbXMgYWJvdXQgd2h5IHRoZWlyIFwiY3JlYXRlIFhcIiByb3V0ZSBub3Qgd29ya2luZy5cbiAgICBtZXRob2RzOiBvcHRpb25zLm1ldGhvZHMgfHwgWydnZXQnLCAnaGVhZCddLFxuICAgIGNhY2hlUHJlZGljYXRlOiBvcHRpb25zLmNhY2hlUHJlZGljYXRlIHx8IHtcbiAgICAgIC8vIEFsbCBjYWNoZWFibGUgc3RhdHVzIGNvZGVzIGRlZmluZWQgaW4gUkZDIDcyMzFcbiAgICAgIHN0YXR1c0NoZWNrOiBzdGF0dXMgPT4gWzIwMCwgMjAzLCAzMDAsIDMwMSwgMzAyLCA0MDQsIDQwNSwgNDEwLCA0MTQsIDUwMV0uaW5jbHVkZXMoc3RhdHVzKVxuICAgIH0sXG4gICAgZXRhZzogKF9vcHRpb25zJGV0YWcgPSBvcHRpb25zLmV0YWcpICE9IG51bGwgPyBfb3B0aW9ucyRldGFnIDogdHJ1ZSxcbiAgICAvLyBUaGlzIG9wdGlvbiBpcyBnb2luZyB0byBiZSBpZ25vcmVkIGJ5IHNlcnZlcnMgd2hlbiBFVGFnIGlzIGVuYWJsZWRcbiAgICAvLyBDaGVja3Mgc3RyaWN0IGVxdWFsaXR5IHRvIGZhbHNlIHRvIGF2b2lkIHVuZGVmaW5lZC1pc2ggdmFsdWVzXG4gICAgbW9kaWZpZWRTaW5jZTogKF9vcHRpb25zJG1vZGlmaWVkU2luYyA9IG9wdGlvbnMubW9kaWZpZWRTaW5jZSkgIT0gbnVsbCA/IF9vcHRpb25zJG1vZGlmaWVkU2luYyA6IG9wdGlvbnMuZXRhZyA9PT0gZmFsc2UsXG4gICAgaW50ZXJwcmV0SGVhZGVyOiAoX29wdGlvbnMkaW50ZXJwcmV0SGVhID0gb3B0aW9ucy5pbnRlcnByZXRIZWFkZXIpICE9IG51bGwgPyBfb3B0aW9ucyRpbnRlcnByZXRIZWEgOiB0cnVlLFxuICAgIGNhY2hlVGFrZW92ZXI6IChfb3B0aW9ucyRjYWNoZVRha2VvdmUgPSBvcHRpb25zLmNhY2hlVGFrZW92ZXIpICE9IG51bGwgPyBfb3B0aW9ucyRjYWNoZVRha2VvdmUgOiB0cnVlLFxuICAgIHN0YWxlSWZFcnJvcjogKF9vcHRpb25zJHN0YWxlSWZFcnJvciA9IG9wdGlvbnMuc3RhbGVJZkVycm9yKSAhPSBudWxsID8gX29wdGlvbnMkc3RhbGVJZkVycm9yIDogdHJ1ZSxcbiAgICBvdmVycmlkZTogKF9vcHRpb25zJG92ZXJyaWRlID0gb3B0aW9ucy5vdmVycmlkZSkgIT0gbnVsbCA/IF9vcHRpb25zJG92ZXJyaWRlIDogZmFsc2UsXG4gICAgaHlkcmF0ZTogKF9vcHRpb25zJGh5ZHJhdGUgPSBvcHRpb25zLmh5ZHJhdGUpICE9IG51bGwgPyBfb3B0aW9ucyRoeWRyYXRlIDogdW5kZWZpbmVkXG4gIH07XG4gIC8vIEFwcGx5IGludGVyY2VwdG9yc1xuICBheGlvc0NhY2hlLmludGVyY2VwdG9ycy5yZXF1ZXN0LnVzZShheGlvc0NhY2hlLnJlcXVlc3RJbnRlcmNlcHRvci5vbkZ1bGZpbGxlZCwgYXhpb3NDYWNoZS5yZXF1ZXN0SW50ZXJjZXB0b3Iub25SZWplY3RlZCk7XG4gIGF4aW9zQ2FjaGUuaW50ZXJjZXB0b3JzLnJlc3BvbnNlLnVzZShheGlvc0NhY2hlLnJlc3BvbnNlSW50ZXJjZXB0b3Iub25GdWxmaWxsZWQsIGF4aW9zQ2FjaGUucmVzcG9uc2VJbnRlcmNlcHRvci5vblJlamVjdGVkKTtcbiAgcmV0dXJuIGF4aW9zQ2FjaGU7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNpbXBsZSBzdG9yYWdlLiBZb3UgY2FuIHBlcnNpc3QgaGlzIGRhdGEgYnkgdXNpbmcgYHNlc3Npb25TdG9yYWdlYCBvclxuICogYGxvY2FsU3RvcmFnZWAgd2l0aCBpdC5cbiAqXG4gKiAqKkltcGxOb3RlKio6IFdpdGhvdXQgcG9seWZpbGwsIHRoaXMgc3RvcmFnZSBvbmx5IHdvcmtzIG9uIGJyb3dzZXIgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIGNvbnN0IGZyb21Mb2NhbFN0b3JhZ2UgPSBidWlsZFdlYlN0b3JhZ2UobG9jYWxTdG9yYWdlKTtcbiAqIGNvbnN0IGZyb21TZXNzaW9uU3RvcmFnZSA9IGJ1aWxkV2ViU3RvcmFnZShzZXNzaW9uU3RvcmFnZSk7XG4gKlxuICogY29uc3QgbXlTdG9yYWdlID0gbmV3IFN0b3JhZ2UoKTtcbiAqIGNvbnN0IGZyb21NeVN0b3JhZ2UgPSBidWlsZFdlYlN0b3JhZ2UobXlTdG9yYWdlKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzdG9yYWdlIFRoZSB0eXBlIG9mIHdlYiBzdG9yYWdlIHRvIHVzZS4gbG9jYWxTdG9yYWdlIG9yIHNlc3Npb25TdG9yYWdlLlxuICogQHBhcmFtIHByZWZpeCBUaGUgcHJlZml4IHRvIGluZGV4IHRoZSBzdG9yYWdlLiBVc2VmdWwgdG8gcHJldmVudCBjb2xsaXNpb24gYmV0d2VlblxuICogICBtdWx0aXBsZSBwbGFjZXMgdXNpbmcgdGhlIHNhbWUgc3RvcmFnZS5cbiAqL1xuZnVuY3Rpb24gYnVpbGRXZWJTdG9yYWdlKHN0b3JhZ2UsIHByZWZpeCA9ICdheGlvcy1jYWNoZS0nKSB7XG4gIHJldHVybiBidWlsZFN0b3JhZ2Uoe1xuICAgIGNsZWFyOiAoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBzdG9yYWdlKSB7XG4gICAgICAgIGlmIChrZXkuc3RhcnRzV2l0aChwcmVmaXgpKSB7XG4gICAgICAgICAgc3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGZpbmQ6IGtleSA9PiB7XG4gICAgICBjb25zdCBqc29uID0gc3RvcmFnZS5nZXRJdGVtKHByZWZpeCArIGtleSk7XG4gICAgICByZXR1cm4ganNvbiA/IEpTT04ucGFyc2UoanNvbikgOiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICByZW1vdmU6IGtleSA9PiB7XG4gICAgICBzdG9yYWdlLnJlbW92ZUl0ZW0ocHJlZml4ICsga2V5KTtcbiAgICB9LFxuICAgIHNldDogKGtleSwgdmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IHNhdmUgPSAoKSA9PiBzdG9yYWdlLnNldEl0ZW0ocHJlZml4ICsga2V5LCBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHNhdmUoKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IGFsbFZhbHVlcyA9IE9iamVjdC5lbnRyaWVzKHN0b3JhZ2UpLmZpbHRlcihpdGVtID0+IGl0ZW1bMF0uc3RhcnRzV2l0aChwcmVmaXgpKS5tYXAoaXRlbSA9PiBbaXRlbVswXSwgSlNPTi5wYXJzZShpdGVtWzFdKV0pO1xuICAgICAgICAvLyBSZW1vdmUgYWxsIGV4cGlyZWQgdmFsdWVzXG4gICAgICAgIGZvciAoY29uc3QgX3ZhbHVlIG9mIGFsbFZhbHVlcykge1xuICAgICAgICAgIGlmIChfdmFsdWVbMV0uc3RhdGUgPT09ICdjYWNoZWQnICYmIGlzRXhwaXJlZChfdmFsdWVbMV0pICYmICFjYW5TdGFsZShfdmFsdWVbMV0pKSB7XG4gICAgICAgICAgICBzdG9yYWdlLnJlbW92ZUl0ZW0oX3ZhbHVlWzBdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHJ5IHNhdmUgYWdhaW4gYWZ0ZXIgcmVtb3ZpbmcgZXhwaXJlZCB2YWx1ZXNcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gc2F2ZSgpO1xuICAgICAgICB9IGNhdGNoIChfdW51c2VkKSB7XG4gICAgICAgICAgLy8gU3RvcmFnZSBzdGlsbCBmdWxsLCB0cnkgcmVtb3ZpbmcgdGhlIG9sZGVzdCB2YWx1ZSB1bnRpbCBpdCBjYW4gYmUgc2F2ZWRcbiAgICAgICAgICAvLyBEZXNjZW5kaW5nIHNvcnQgYnkgY3JlYXRlZEF0XG4gICAgICAgICAgY29uc3Qgc29ydGVkSXRlbXMgPSBhbGxWYWx1ZXMuc29ydCgoYSwgYikgPT4gKGFbMV0uY3JlYXRlZEF0IHx8IDApIC0gKGJbMV0uY3JlYXRlZEF0IHx8IDApKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2Ygc29ydGVkSXRlbXMpIHtcbiAgICAgICAgICAgIHN0b3JhZ2UucmVtb3ZlSXRlbShpdGVtWzBdKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBzYXZlKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChfdW51c2VkMikge1xuICAgICAgICAgICAgICAvLyBUaGlzIGtleSBkaWRuJ3QgZnJlZSBhbGwgdGhlIHJlcXVpcmVkIHNwYWNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENsZWFyIHRoZSBjYWNoZSBmb3IgdGhlIHNwZWNpZmllZCBrZXlcbiAgICAgICAgc3RvcmFnZS5yZW1vdmVJdGVtKHByZWZpeCArIGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0IHsgSGVhZGVyLCBidWlsZEtleUdlbmVyYXRvciwgYnVpbGRNZW1vcnlTdG9yYWdlLCBidWlsZFN0b3JhZ2UsIGJ1aWxkV2ViU3RvcmFnZSwgY2FuU3RhbGUsIGNyZWF0ZUNhY2hlUmVzcG9uc2UsIGNyZWF0ZVZhbGlkYXRlU3RhdHVzLCBkZWZhdWx0SGVhZGVySW50ZXJwcmV0ZXIsIGRlZmF1bHRLZXlHZW5lcmF0b3IsIGRlZmF1bHRSZXF1ZXN0SW50ZXJjZXB0b3IsIGRlZmF1bHRSZXNwb25zZUludGVyY2VwdG9yLCBpc0V4cGlyZWQsIGlzTWV0aG9kSW4sIGlzU3RvcmFnZSwgbXVzdFJldmFsaWRhdGUsIHJlZ2V4T3JTdHJpbmdNYXRjaCwgc2V0dXBDYWNoZSwgdGVzdENhY2hlUHJlZGljYXRlLCB1cGRhdGVDYWNoZSwgdXBkYXRlU3RhbGVSZXF1ZXN0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tb2Rlcm4uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/axios-cache-interceptor/dist/index.modern.js\n");

/***/ })

};
;